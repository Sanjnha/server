From 7a8b377b2f6898c1f03bc7a4d374fefeb1195217 Mon Sep 17 00:00:00 2001
From: Piotr M <mrow4a@yahoo.com>
Date: Thu, 4 Aug 2016 14:02:57 +0200
Subject: [PATCH 1/4] Feature: Bundling version 1 - Implement bundling using
 multipart, MultipartContentsParser, BundledFile unit tests with bugfixes

---
 apps/dav/lib/Capabilities.php                 |   8 +-
 apps/dav/lib/Connector/Sabre/File.php         |  10 +-
 apps/dav/lib/Connector/Sabre/QuotaPlugin.php  |   6 +-
 apps/dav/lib/Files/BundledFile.php            | 180 ++++++++
 apps/dav/lib/Files/BundlingPlugin.php         | 411 ++++++++++++++++++
 .../dav/lib/Files/MultipartContentsParser.php | 285 ++++++++++++
 apps/dav/lib/Server.php                       |   4 +
 apps/dav/tests/temporary/bundling_tests.sh    |  65 +++
 apps/dav/tests/temporary/put_test.sh          |  11 +
 apps/dav/tests/temporary/zombie.jpg           | Bin 0 -> 22014 bytes
 apps/dav/tests/unit/Files/BundledFileTest.php | 169 +++++++
 .../Files/MultipartContentsParserTest.php     | 379 ++++++++++++++++
 12 files changed, 1518 insertions(+), 10 deletions(-)
 create mode 100644 apps/dav/lib/Files/BundledFile.php
 create mode 100644 apps/dav/lib/Files/BundlingPlugin.php
 create mode 100644 apps/dav/lib/Files/MultipartContentsParser.php
 create mode 100755 apps/dav/tests/temporary/bundling_tests.sh
 create mode 100755 apps/dav/tests/temporary/put_test.sh
 create mode 100644 apps/dav/tests/temporary/zombie.jpg
 create mode 100644 apps/dav/tests/unit/Files/BundledFileTest.php
 create mode 100644 apps/dav/tests/unit/Files/MultipartContentsParserTest.php

diff --git a/apps/dav/lib/Capabilities.php b/apps/dav/lib/Capabilities.php
index c6f63b374207..3f764fd29543 100644
--- a/apps/dav/lib/Capabilities.php
+++ b/apps/dav/lib/Capabilities.php
@@ -1,8 +1,9 @@
 <?php
-/**
- * @author Thomas Müller <thomas.mueller@tmit.eu>
+/**\
+ * @author Thomas Müller <thomas.mueller@tmit.eu>\
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
  *
- * @copyright Copyright (c) 2016, ownCloud GmbH
+ * @copyright Copyright (c) 2016, ownCloud GmbH.\
  * @license AGPL-3.0
  *
  * This code is free software: you can redistribute it and/or modify
@@ -30,6 +31,7 @@ public function getCapabilities() {
 		return [
 			'dav' => [
 				'chunking' => '1.0',
+				'bundlerequest' => true,
 			]
 		];
 	}
diff --git a/apps/dav/lib/Connector/Sabre/File.php b/apps/dav/lib/Connector/Sabre/File.php
index 6c928c4d1b7a..82eeb4af1de5 100644
--- a/apps/dav/lib/Connector/Sabre/File.php
+++ b/apps/dav/lib/Connector/Sabre/File.php
@@ -232,7 +232,7 @@ public function put($data) {
 		return '"' . $this->info->getEtag() . '"';
 	}
 
-	private function getPartFileBasePath($path) {
+	protected function getPartFileBasePath($path) {
 		$partFileInStorage = \OC::$server->getConfig()->getSystemValue('part_file_in_storage', true);
 		if ($partFileInStorage) {
 			return $path;
@@ -244,7 +244,7 @@ private function getPartFileBasePath($path) {
 	/**
 	 * @param string $path
 	 */
-	private function emitPreHooks($exists, $path = null) {
+	protected function emitPreHooks($exists, $path = null) {
 		if (is_null($path)) {
 			$path = $this->path;
 		}
@@ -272,7 +272,7 @@ private function emitPreHooks($exists, $path = null) {
 	/**
 	 * @param string $path
 	 */
-	private function emitPostHooks($exists, $path = null) {
+	protected function emitPostHooks($exists, $path = null) {
 		if (is_null($path)) {
 			$path = $this->path;
 		}
@@ -502,7 +502,7 @@ private function createFileChunked($data) {
 	 * @param \OCP\Files\Storage $storage
 	 * @return bool true if the storage needs part file handling
 	 */
-	private function needsPartFile($storage) {
+	protected function needsPartFile($storage) {
 		// TODO: in the future use ChunkHandler provided by storage
 		// and/or add method on Storage called "needsPartFile()"
 		return !$storage->instanceOfStorage('OCA\Files_Sharing\External\Storage') &&
@@ -516,7 +516,7 @@ private function needsPartFile($storage) {
 	 *
 	 * @throws \Sabre\DAV\Exception
 	 */
-	private function convertToSabreException(\Exception $e) {
+	protected function convertToSabreException(\Exception $e) {
 		if ($e instanceof \Sabre\DAV\Exception) {
 			throw $e;
 		}
diff --git a/apps/dav/lib/Connector/Sabre/QuotaPlugin.php b/apps/dav/lib/Connector/Sabre/QuotaPlugin.php
index 508253d8ea91..a8f9010c7fd0 100644
--- a/apps/dav/lib/Connector/Sabre/QuotaPlugin.php
+++ b/apps/dav/lib/Connector/Sabre/QuotaPlugin.php
@@ -73,8 +73,10 @@ public function initialize(\Sabre\DAV\Server $server) {
 
 		$this->server = $server;
 
-		$server->on('beforeWriteContent', [$this, 'checkQuota'], 10);
-		$server->on('beforeCreateFile', [$this, 'checkQuota'], 10);
+		$server->on('beforeWriteContent', array($this, 'checkQuota'), 10);
+		$server->on('beforeCreateFile', array($this, 'checkQuota'), 10);
+		$server->on('beforeWriteBundle', array($this, 'checkQuota'), 10);
+		
 	}
 
 	/**
diff --git a/apps/dav/lib/Files/BundledFile.php b/apps/dav/lib/Files/BundledFile.php
new file mode 100644
index 000000000000..bb75979c250e
--- /dev/null
+++ b/apps/dav/lib/Files/BundledFile.php
@@ -0,0 +1,180 @@
+<?php
+/**
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
+ *
+ * @copyright Copyright (c) 2016, ownCloud GmbH.
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+namespace OCA\DAV\Files;
+
+use OCA\DAV\Connector\Sabre\Exception\FileLocked;
+use OCP\Files\StorageNotAvailableException;
+use OCP\Lock\ILockingProvider;
+use OCP\Lock\LockedException;
+use Sabre\DAV\Exception;
+use Sabre\DAV\Exception\Forbidden;
+use Sabre\DAV\Exception\ServiceUnavailable;
+use OCA\DAV\Connector\Sabre\File;
+
+class BundledFile extends File {
+
+	private $partFilePath = null;
+
+	/**
+	 * TODO
+	 *
+	 * @throws TODO
+	 * @return resource $property
+	 */
+	public function getPartFileResource() {
+		// verify path of the target
+		$this->verifyPath();
+
+		$this->partFilePath = $this->getPartFileBasePath($this->path) . '.ocTransferId' . rand() . '.part';
+
+		// the part file and target file might be on a different storage in case of a single file storage (e.g. single file share)
+		/** @var \OC\Files\Storage\Storage $partStorage */
+		list($partStorage, $internalPartPath) = $this->fileView->resolvePath($this->partFilePath);
+
+		$target = $partStorage->fopen($internalPartPath, 'wb');
+		if ($target === false) {
+			\OCP\Util::writeLog('webdav', '\OC\Files\Filesystem::fopen() failed', \OCP\Util::ERROR);
+				// because we have no clue about the cause we can only throw back a 500/Internal Server Error
+			$this->partFilePath = null;
+			throw new Exception('Could not write file contents');
+		}
+
+		return $target;
+	}
+
+	/**
+	 * TODO
+	 *
+	 * @return void
+	 */
+	public function unlinkPartFile() {
+		//Prerequisite here is that partFile has to be already existing
+		if ($this->partFilePath != null) {
+			list($partStorage, $internalPartPath) = $this->fileView->resolvePath($this->partFilePath);
+			$partStorage->unlink($internalPartPath);
+		}
+	}
+	/**
+	 * Creates the data
+	 *
+	 * The data argument is a readable stream
+	 *
+	 * @param resource $fileData
+	 * @param array $fileAttributes
+	 *
+	 * @throws TODO
+	 * @return Array $property
+	 */
+	public function createFile($fileAttributes) {
+		//Prerequisite here is that partFile has to be already existing
+		if ($this->partFilePath == null) {
+			throw new Forbidden('Part file does not exists, cannot create target file');
+		}
+
+		$exists = $this->fileView->file_exists($this->path);
+		if ($this->info && $exists) {
+			throw new Forbidden('File does exists, cannot create file');
+		}
+		// verify path of the target
+		$this->verifyPath();
+
+		/** @var \OC\Files\Storage\Storage $storage */
+		list($storage, $internalPath) = $this->fileView->resolvePath($this->path);
+		list($partStorage, $internalPartPath) = $this->fileView->resolvePath($this->partFilePath);
+
+		try {
+			$view = \OC\Files\Filesystem::getView();
+			if ($view) {
+				$run = $this->emitPreHooks($exists);
+			} else {
+				$run = true;
+			}
+
+			try {
+				$this->changeLock(ILockingProvider::LOCK_EXCLUSIVE);
+			} catch (LockedException $e) {
+				$partStorage->unlink($internalPartPath);
+				throw new FileLocked($e->getMessage(), $e->getCode(), $e);
+			}
+
+			try {
+				if ($run) {
+					$renameOkay = $storage->moveFromStorage($partStorage, $internalPartPath, $internalPath);
+					$fileExists = $storage->file_exists($internalPath);
+				}
+				if (!$run || $renameOkay === false || $fileExists === false) {
+					\OCP\Util::writeLog('webdav', 'renaming part file to final file failed', \OCP\Util::ERROR);
+					throw new Exception('Could not rename part file to final file');
+				}
+			} catch (\Exception $e) {
+				$this->unlinkPartFile();
+				$this->convertToSabreException($e);
+			}
+
+			// since we skipped the view we need to scan and emit the hooks ourselves
+			$storage->getUpdater()->update($internalPath);
+
+			try {
+				$this->changeLock(ILockingProvider::LOCK_SHARED);
+			} catch (LockedException $e) {
+				$this->unlinkPartFile();
+				throw new FileLocked($e->getMessage(), $e->getCode(), $e);
+			}
+
+			if ($view) {
+				$this->emitPostHooks($exists);
+			}
+			
+			// allow sync clients to send the mtime along in a header
+			if (isset($fileAttributes['x-oc-mtime'])) {
+				if ($this->fileView->touch($this->path, $fileAttributes['x-oc-mtime'])) {
+					$property['{DAV:}x-oc-mtime'] = 'accepted'; //TODO: not sure about that
+				}
+			}
+
+			$this->refreshInfo();
+
+		} catch (StorageNotAvailableException $e) {
+			$this->unlinkPartFile();
+			throw new ServiceUnavailable("Failed to check file size: " . $e->getMessage());
+		}
+
+		//TODO add proper attributes
+		$etag = $this->getEtag();
+		$property['{DAV:}etag'] = $etag; //TODO: not sure about that
+		$property['{DAV:}oc-etag'] = $etag; //TODO: not sure about that
+		$property['{DAV:}oc-fileid'] = $this->getFileId();//TODO: not sure about that
+		return $property;
+	}
+
+	/**
+	 *
+	 * TODO: description
+	 *
+	 * @param resource $data
+	 *
+	 * @throws Forbidden
+	 */
+	public function put($data) {
+		throw new Forbidden('PUT method not supported for bundling');
+	}
+}
\ No newline at end of file
diff --git a/apps/dav/lib/Files/BundlingPlugin.php b/apps/dav/lib/Files/BundlingPlugin.php
new file mode 100644
index 000000000000..a580714b8a95
--- /dev/null
+++ b/apps/dav/lib/Files/BundlingPlugin.php
@@ -0,0 +1,411 @@
+<?php
+/**
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
+ *
+ * @copyright Copyright (c) 2016, ownCloud GmbH.
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+namespace OCA\DAV\Files;
+
+use Sabre\DAV\ServerPlugin;
+use Sabre\HTTP\RequestInterface;
+use Sabre\HTTP\ResponseInterface;
+use OC\Files\View;
+use Sabre\HTTP\URLUtil;
+use OCP\Lock\ILockingProvider;
+use OC\Files\FileInfo;
+use Sabre\DAV\Exception\Forbidden;
+use Sabre\DAV\Exception\BadRequest;
+use Sabre\DAV\Exception;
+
+/**
+ * This plugin is responsible for interconnecting three components of the OC server:
+ * - RequestInterface object handler for request incoming from the client
+ * - MultipartContentsParser responsible for reading the contents of the request body
+ * - BundledFile responsible for storage of the file associated with request in the OC server
+ *
+ * Bundling plugin is responsible for receiving, validation and processing of the multipart/related request containing files.
+ *
+ */
+class BundlingPlugin extends ServerPlugin {
+
+	/**
+	 * Reference to main server object
+	 *
+	 * @var \Sabre\DAV\Server
+	 */
+	private $server;
+
+	/**
+	 * @var \Sabre\HTTP\RequestInterface
+	 */
+	private $request;
+
+	/**
+	 * @var \Sabre\HTTP\ResponseInterface
+	 */
+	private $response;
+
+	/**
+	 * @var String
+	 */
+	private $boundary = null;
+
+	/**
+	 * @var \OCA\DAV\FilesBundle
+	 */
+	private $contentHandler = null;
+
+	/**
+	 * @var String
+	 */
+	private $userFilesHome = null;
+
+	/**
+	 * @var View
+	 */
+	private $fileView;
+
+	/**
+	 * @var Array
+	 */
+	private $cacheValidParents = null;
+	
+	/**
+	 * Plugin contructor
+	 */
+	public function __construct(View $view) {
+		$this->fileView = $view;
+	}
+
+	/**
+	 * This initializes the plugin.
+	 *
+	 * This function is called by \Sabre\DAV\Server, after
+	 * addPlugin is called.
+	 *
+	 * This method should set up the requires event subscriptions.
+	 *
+	 * @param \Sabre\DAV\Server $server
+	 * @return void
+	 */
+	public function initialize(\Sabre\DAV\Server $server) {
+
+		$this->server = $server;
+
+		$server->on('method:POST', array($this, 'handleBundledUpload'));
+	}
+
+	/**
+	 * We intercept this to handle method:POST on a dav resource and process the bundled files multipart HTTP request.
+	 *
+	 * @param RequestInterface $request
+	 * @param ResponseInterface $response
+	 *
+	 * @throws /Sabre\DAV\Exception\BadRequest
+	 * @throws /Sabre\DAV\Exception\Forbidden
+	 * @return null|false
+	 */
+	public function handleBundledUpload(RequestInterface $request, ResponseInterface $response) {
+		$this->request = $request;
+		$this->response = $response;
+
+		//TODO: add emit (beforeBind)
+
+		//validate the request before parsing
+		$this->validateRequest();
+
+		//TODO: ensure to sign in proper classes to this emit
+		if (!$this->server->emit('beforeWriteBundle', [$this->userFilesHome])){
+			throw new Forbidden('beforeWriteBundle preconditions failed');
+		}
+
+		//Update the content handler of the bundle body
+		$this->contentHandler = $this->getContentHandler($this->request);
+		
+		//Create JSON from metadata content in the bundle
+		$bundleMetadata = $this->getBundleMetadata();
+
+		//Process bundle and send a multistatus response
+		$result = $this->processBundle($bundleMetadata);
+
+		//TODO: add emit (afterBind)
+		//TODO: add emit (afterCreateFile)
+		return $result;
+	}
+
+	/**
+	 * Adds to multistatus response exception class string and exception message for specific file
+	 *
+	 * @return void
+	 */
+	protected function handleFileMultiStatusError(&$bundleResponseProperties, $ocPath, $status, $propertyException, $propertyMessage){
+		$entry['href'] = $this->userFilesHome;
+		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}exception'] = $propertyException;
+		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}message'] = $propertyMessage;
+		$entry[$status]['{DAV:}oc-path'] = $ocPath;
+		$bundleResponseProperties[] = $entry;
+	}
+
+	/**
+	 * TODO: description and variables
+	 *
+	 * @return void
+	 */
+	protected function handleFileMultiStatus(&$bundleResponseProperties, $ocPath, $status, $properties){
+		$entry['href'] = $this->userFilesHome;
+		$entry[$status] = $properties;
+		$entry[$status]['{DAV:}oc-path'] = $ocPath;
+		$bundleResponseProperties[] = $entry;
+	}
+
+	/**
+	 * Get content handler
+	 *
+	 * @param  RequestInterface $request
+	 * @param  String $boundary
+	 * @throws TODO: handle exception
+	 * @return array
+	 */
+	protected function getContentHandler(RequestInterface $request) {
+		if ($this->contentHandler === null) {
+			return new MultipartContentsParser($request);
+		}
+			return $this->contentHandler;
+	}
+
+
+	/**
+	 * Check multipart headers.
+	 *
+	 * @throws /Sabre\DAV\Exception\BadRequest
+	 * @throws /Sabre\DAV\Exception\Forbidden
+	 * @return void
+	 */
+	private function validateRequest() {
+		// Making sure the end node exists
+		//TODO: add support for user creation if that is first sync. Currently user has to be created.
+		$this->userFilesHome = $this->request->getPath();
+		$userFilesHomeNode = $this->server->tree->getNodeForPath($this->userFilesHome);
+		if (!($userFilesHomeNode instanceof FilesHome)){
+			throw new BadRequest('URL endpoint has to be instance of \OCA\DAV\Files\FilesHome');
+		}
+
+		$headers = array('Content-Type');
+		foreach ($headers as $header) {
+			$value = $this->request->getHeader($header);
+			if ($value === null) {
+				throw new BadRequest(sprintf('%s header is needed', $header));
+			} elseif (!is_int($value) && empty($value)) {
+				throw new BadRequest(sprintf('%s header must not be empty', $header));
+			}
+		}
+
+		//Validate content-type
+		$contentParts = explode(';', $this->request->getHeader('Content-Type'));
+		if (count($contentParts) != 2) {
+			throw new Forbidden('Improper Content-type format. Boundary may be missing');
+		}
+		$contentType = trim($contentParts[0]);
+		$expectedContentType = 'multipart/related';
+		if ($contentType != $expectedContentType) {
+			//TODO: handle exception
+			throw new BadRequest(sprintf(
+				'Content-Type must be %s',
+				$expectedContentType
+			));
+		}
+
+		//Validate boundrary
+		$boundaryPart = trim($contentParts[1]);
+		$shouldStart = 'boundary=';
+		if (substr($boundaryPart, 0, strlen($shouldStart)) != $shouldStart) {
+			throw new BadRequest('Boundary is not set');
+		}
+		$boundary = substr($boundaryPart, strlen($shouldStart));
+		if (substr($boundary, 0, 1) == '"' && substr($boundary, -1) == '"') {
+			$boundary = substr($boundary, 1, -1);
+		}
+		$this->boundary = $boundary;
+	}
+
+	/**
+	 * Get the bundle metadata from the request.
+	 *
+	 * Note: MUST be called before getBundleContents, and just one time.
+	 *
+	 * @throws /Sabre\DAV\Exception\BadRequest
+	 * @return array
+	 */
+	private function getBundleMetadata() {
+		$metadataContentHeader = $this->contentHandler->getPartHeaders($this->boundary);
+		if (!isset($metadataContentHeader['content-type'])) {
+			throw new BadRequest('Metadata does not contain content-type header');
+		}
+		$expectedContentType = 'application/json';
+		if (substr($metadataContentHeader['content-type'], 0, strlen($expectedContentType)) != $expectedContentType) {
+			throw new BadRequest(sprintf(
+				'Expected content type of first part is %s. Found %s',
+				$expectedContentType,
+				$metadataContentHeader['content-type']
+			));
+		}
+
+		if (!isset($metadataContentHeader['content-length'])) {
+			throw new BadRequest('Metadata does not contain content-length header');
+		}
+
+		$metaDataContent = $this->contentHandler->streamReadToString($metadataContentHeader['content-length']);
+
+		if (isset($metadataContentHeader['content-md5'])) {
+			//check if the expected metadata is corrupted
+			$contentMD5 = $metadataContentHeader['content-md5'];
+			$hash = md5($metaDataContent);
+			if (!($hash === $contentMD5)) {
+				throw new BadRequest(sprintf(
+					'Received wrong metadata. Expected Content-MD5 %s, expected %s',
+					$contentMD5,
+					$hash
+				));
+			}
+		}
+
+		//rewind to the begining of file for streamCopy and copy stream
+		$jsonContent = json_decode($metaDataContent, true);
+		if ($jsonContent === null) {
+			throw new BadRequest('Unable to parse JSON');
+		}
+
+		return $jsonContent;
+	}
+
+	/**
+	 * Process multipart contents and send appropriete response
+	 *
+	 * @return boolean
+	 */
+	private function processBundle($bundleMetadata) {
+		$bundleResponseProperties = array();
+
+		while(!$this->contentHandler->getEndDelimiterReached()) {
+			//get multipart header for one of the contents
+			try{
+				$bundleContentHeader = $this->contentHandler->getPartHeaders($this->boundary);
+			}
+			catch (Exception $e) {
+				throw new BadRequest($e->getMessage());
+			}
+
+			if ($bundleContentHeader === null && $this->contentHandler->getEndDelimiterReached()){
+				//endDelimiter reached, break
+				break;
+			}
+
+			if (!isset($bundleContentHeader['content-length'])) {
+				throw new BadRequest('File header does not contain Content-Length. Unable to parse whole bundle request');
+			}
+			
+			if (!isset($bundleContentHeader['content-id'])) {
+				//part is multipart/related, but header contains too less data to create file or signilizes EndDelimiterReached, ignore
+				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);
+				continue;
+			}
+			
+			//try to match content part header to bundleMetadata for that bundleContent
+			$binaryID = $bundleContentHeader['content-id'];
+			if (!isset($bundleMetadata[$binaryID])){
+				//part is multipart/related, but content-id in header does not match any of the files
+				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);
+				continue;
+			}
+			$fileAttributes = $bundleMetadata[$binaryID];
+
+			//process oc-path
+			if (!isset($fileAttributes['oc-path'])){
+				//without oc-path we cannot contruct multistatus response
+				throw new BadRequest('File metadata does not contain required key - value pair containing oc-path');
+			}
+
+			//get oc-path of the file
+			$filePath = $fileAttributes['oc-path'];
+			list($folderPath, $fileName) = URLUtil::splitPath($filePath);
+
+			if ($folderPath === ''){
+				$fullFolderPath = $this->userFilesHome;
+			}
+			else{
+				$fullFolderPath = $this->userFilesHome . '/' . $folderPath;
+			}
+
+			//validate parent folder
+			if (!isset($this->cacheValidParents[$folderPath])){
+				$this->cacheValidParents[$folderPath] = ($this->server->tree->nodeExists($fullFolderPath) && $this->fileView->isCreatable($folderPath));
+			}
+
+			if (!$this->cacheValidParents[$folderPath]) {
+				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);	
+				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', 'File creation on not existing or without creation permission parent folder is not permitted');
+				continue;
+			}
+
+			//get absolute path of the file
+			$absoluteFilePath = $this->fileView->getAbsolutePath($folderPath) . '/' . $fileName;
+			$info = new FileInfo($absoluteFilePath, null, null, array(), null);
+			$node = new BundledFile($this->fileView, $info);
+
+			try{
+				$target = $node->getPartFileResource();
+			} catch (\Exception $e) {
+				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);
+				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', $e->getMessage());
+				continue;
+			}
+			
+			if (!$this->contentHandler->streamReadToStream($target, $bundleContentHeader['content-length'])){
+				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', 'Error reading the file contents');
+			}
+			fclose($target);
+
+			try{
+				$node->acquireLock(ILockingProvider::LOCK_SHARED);
+			} catch (\Exception $e) {
+				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', $e->getMessage());
+				continue;
+			}
+
+			try{
+				$properties = $node->createFile($fileAttributes);
+			} catch (\Exception $e) {
+				$node->releaseLock(ILockingProvider::LOCK_SHARED);
+				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', $e->getMessage());
+				continue;
+			}
+
+			$node->releaseLock(ILockingProvider::LOCK_SHARED);
+			$this->server->tree->markDirty($filePath);
+			$this->handleFileMultiStatus($bundleResponseProperties, $filePath, 200, $properties);
+		}
+
+		//multistatus response anounced
+		$this->response->setHeader('Content-Type', 'application/xml; charset=utf-8');
+		$this->response->setStatus(207);
+		$data = $this->server->generateMultiStatus($bundleResponseProperties);
+		$this->response->setBody($data);
+
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/apps/dav/lib/Files/MultipartContentsParser.php b/apps/dav/lib/Files/MultipartContentsParser.php
new file mode 100644
index 000000000000..53299e071563
--- /dev/null
+++ b/apps/dav/lib/Files/MultipartContentsParser.php
@@ -0,0 +1,285 @@
+<?php
+/**
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
+ *
+ * @copyright Copyright (c) 2016, ownCloud GmbH.
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+namespace OCA\DAV\Files;
+
+use Sabre\HTTP\RequestInterface;
+use Sabre\DAV\Exception\BadRequest;
+
+/**
+ * This class is used to parse multipart/related HTTP message according to RFC http://www.rfc-archive.org/getrfc.php?rfc=2387
+ * This class requires a message to contain Content-length parameters, which is used in high performance reading of file contents.
+ */
+
+class MultipartContentsParser {
+    /**
+     * @var \Sabre\HTTP\RequestInterface
+     */
+    private $request;
+
+    /**
+     * @var resource
+     */
+    private $content = null;
+
+    /**
+     * @var Bool
+     */
+    private $endDelimiterReached = false;
+
+    /**
+     * Constructor.
+     *
+     * @param \Sabre\HTTP\RequestInterface $request
+     */
+    public function __construct(RequestInterface $request) {
+        $this->request = $request;
+    }
+
+    /**
+     * Get a line.
+     *
+     * If false is return, it's the end of file.
+     *
+     * @throws \Sabre\DAV\Exception\BadRequest
+     * @return string|boolean
+     */
+    public function gets() {
+        $content = $this->getContent();
+        if (!is_resource($content)) {
+            throw new BadRequest('Unable to get request content');
+        }
+
+        return fgets($content);
+    }
+
+    /**
+     * @return int
+     */
+    public function getCursor() {
+        return ftell($this->getContent());
+    }
+
+    /**
+     * @return int
+     */
+    public function getEndDelimiterReached() {
+        return $this->endDelimiterReached;
+    }
+
+    /**
+     * Return if end of file.
+     *
+     * @return bool
+     */
+    public function eof() {
+        return feof($this->getContent());
+    }
+
+    /**
+     * Seeks to offset of some file contentLength from the current cursor possition in the
+     * multipartContent.
+     *
+     * Return true on success and false on failure
+     *
+     * @return bool
+     */
+    public function multipartContentSeekToContentLength($contentLength) {
+        return (fseek($this->getContent(),$contentLength, SEEK_CUR) === 0 ? true : false);
+    }
+
+    /**
+     * Get request content.
+     *
+     * @return resource
+     * @throws \Sabre\DAV\Exception\BadRequest
+     */
+    public function getContent() {
+        if ($this->content === null) {
+            $this->content = $this->request->getBody();
+
+            if (!$this->content) {
+                throw new BadRequest('Unable to get request content');
+            }
+        }
+
+        return $this->content;
+    }
+
+    /**
+     * Get a part of request separated by boundrary $boundary.
+     *
+     * If this method returns an exception, it means whole request has to be abandoned,
+     * Request part without correct headers might corrupt the message and parsing is imposible
+     *
+     * @param  String $boundary
+     *
+     * @throws \Sabre\DAV\Exception\BadRequest
+     * @return array (array $headers, resource $bodyStream)
+     */
+    public function getPartHeaders($boundary) {
+        $delimiter = '--'.$boundary."\r\n";
+        $endDelimiter = '--'.$boundary.'--';
+        $boundaryCount = 0;
+        $content = '';
+        $headers = null;
+        $body = null;
+
+        while (!$this->eof()) {
+            $line = $this->gets();
+            if ($line === false) {
+                if ($boundaryCount == 0) {
+                    //empty part, ignore
+                    break;
+                }
+                else{
+                    throw new BadRequest('An error appears while reading and parsing header of content part using fgets');
+                }
+            }
+
+            if ($boundaryCount == 0) {
+                if ($line != $delimiter) {
+                    if ($this->getCursor() == strlen($line)) {
+                        throw new BadRequest('Expected boundary delimiter in content part - not a multipart/related request');
+                    }
+                    elseif ($line == $endDelimiter || $line == $endDelimiter."\r\n") {
+                        $this->endDelimiterReached = true;
+                        break;
+                    }
+                    elseif ($line == "\r\n") {
+                        continue;
+                    }
+                } else {
+                    continue;
+                }
+                //at this point we know, that first line was boundrary
+                $boundaryCount++;
+            }
+            elseif ($boundaryCount == 1 && $line == "\r\n"){
+                //header-end according to RFC
+                $content .= $line;
+                $headers = $this->readHeaders($content);
+                break;
+            }
+            elseif ($line == $endDelimiter || $line == $endDelimiter."\r\n") {
+                $this->endDelimiterReached = true;
+                break;
+            }
+
+            $content .= $line;
+        }
+
+        if ($this->eof()){
+            $this->endDelimiterReached = true;
+        }
+
+        return $headers;
+    }
+    
+    /**
+     * Read the contents from the current file pointer to the specified length
+     *
+     * @param int $length
+     * 
+     * @throws \Sabre\DAV\Exception\BadRequest
+     * @return string $buf
+     */
+    public function streamReadToString($length) {
+        if ($length<0) {
+            throw new BadRequest('Method streamRead cannot read contents with negative length');
+        }
+        $source = $this->getContent();
+        $bufChunkSize = 8192;
+        $count = $length;
+        $buf = '';
+
+        while ($count!=0) {
+            $bufSize = (($count - $bufChunkSize)<0) ? $count : $bufChunkSize;
+            $buf .= fread($source, $bufSize);
+            $count -= $bufSize;
+        }
+
+        return $buf;
+    }
+
+    /**
+     * Read the contents from the current file pointer to the specified length and pass
+     *
+     * @param resource $target, int $length
+     *
+     * @throws \Sabre\DAV\Exception\BadRequest
+     * @return bool $result)
+     */
+    public function streamReadToStream($target, $length) {
+        if ($length<0) {
+            throw new BadRequest('Method streamRead cannot read contents with negative length');
+        }
+        $source = $this->getContent();
+        $bufChunkSize = 8192;
+        $count = $length;
+        $returnStatus = true;
+
+        while ($count!=0) {
+            $bufSize = (($count - $bufChunkSize)<0) ? $count : $bufChunkSize;
+            $buf = fread($source, $bufSize);
+            $bytesWritten = fwrite($target, $buf);
+
+            // note: strlen is expensive so only use it when necessary,
+            // on the last block
+            if ($bytesWritten === false
+                || ($bytesWritten < $bufSize && $bytesWritten < strlen($buf))
+            ) {
+                // write error, could be disk full ?
+                $returnStatus = false;
+                break;
+            }
+            $count -= $bufSize;
+        }
+
+        return $returnStatus;
+    }
+
+    
+    /**
+     * Get headers from content
+     *
+     * @param string $content
+     * 
+     * @throws \Sabre\DAV\Exception\BadRequest
+     * @return Array $headers
+     */
+    public function readHeaders($content) {
+        $headerLimitation = strpos($content, "\r\n\r\n");
+        if ($headerLimitation === false) {
+            throw new BadRequest('Unable to determine headers limit for content part');
+        }
+        $headersContent = substr($content, 0, $headerLimitation);
+        $headersContent = trim($headersContent);
+        foreach (explode("\r\n", $headersContent) as $header) {
+            $parts = explode(':', $header);
+            if (count($parts) != 2) {
+                throw new BadRequest('Header of content part contains incorrect headers');
+            }
+            $headers[strtolower(trim($parts[0]))] = trim($parts[1]);
+        }
+
+        return $headers;
+    }
+}
\ No newline at end of file
diff --git a/apps/dav/lib/Server.php b/apps/dav/lib/Server.php
index 95f9dc889307..6dbde47cbf44 100644
--- a/apps/dav/lib/Server.php
+++ b/apps/dav/lib/Server.php
@@ -213,6 +213,10 @@ public function __construct(IRequest $request, $baseUri) {
 						$userFolder
 					));
 				}
+
+				//TODO:verify if this is a proper place for the plugin
+				$this->server->addPlugin(
+					new \OCA\DAV\Files\BundlingPlugin($view));
 			}
 		});
 	}
diff --git a/apps/dav/tests/temporary/bundling_tests.sh b/apps/dav/tests/temporary/bundling_tests.sh
new file mode 100755
index 000000000000..1519e4154899
--- /dev/null
+++ b/apps/dav/tests/temporary/bundling_tests.sh
@@ -0,0 +1,65 @@
+#!/bin/bash
+
+script_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+
+user='admin'
+pass='admin'
+server='localhost:8080'
+upload="/tmp/upload.txt"
+header="/tmp/header.json"
+
+echo -en "{
+  \"1\": {
+    \"oc-path\":\"bundling_tests.sh\",
+    \"x-oc-mtime\":\"1471254375\"
+  },
+  \"2\": {
+    \"oc-path\":\"test/zombie1.jpg\",
+    \"x-oc-mtime\":\"1471254375\"
+  },
+  \"3\": {
+    \"oc-path\":\"test/zombie2.jpg\",
+    \"x-oc-mtime\":\"1471254375\"
+  }
+}" > $header
+
+size0=$(du -sb $header | awk '{ print $1 }')
+md50=$(md5sum $header | awk '{ print $1 }')
+
+testfile1="$script_path/bundling_tests.sh"
+size1=$(du -sb $testfile1 | awk '{ print $1 }')
+md51=$(md5sum $testfile1 | awk '{ print $1 }')
+
+testfile2="$script_path/zombie.jpg"
+size2=$(du -sb $testfile2 | awk '{ print $1 }')
+md52=$(md5sum $testfile2 | awk '{ print $1 }')
+
+mdupload=$(md5sum $upload | awk '{ print $1 }')
+boundrary="boundary_$mdupload"
+
+#METADATA
+echo -en "--$boundrary\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: $size0\r\nContent-MD5: $md50\r\n\r\n" > $upload
+cat $header >> $upload
+
+#CONTENTS
+echo -en "\r\n--$boundrary\r\nContent-ID: 1\r\nContent-length: 4\r\n\r\nabcd" >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 2\r\nContent-length: $size2\r\nContent-MD5: $md52\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 3\r\nContent-length: $size1\r\nContent-MD5: $md51\r\n\r\n" >> $upload
+cat $testfile1 >> $upload
+
+#END BOUNDRARY
+echo -en "\r\n--$boundrary--\r\n" >> $upload
+
+#POST
+#curl -X DELETE -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" "http://$server/remote.php/webdav/config.cfg"
+
+curl -X POST -H "Content-Type: multipart/related; boundary=$boundrary" --cookie "XDEBUG_SESSION=MROW4A;path=/;" \
+    --data-binary "@$upload" \
+    "http://$user:$pass@$server/remote.php/dav/files/$user"
+
+
+
+
diff --git a/apps/dav/tests/temporary/put_test.sh b/apps/dav/tests/temporary/put_test.sh
new file mode 100755
index 000000000000..40b14ee833d5
--- /dev/null
+++ b/apps/dav/tests/temporary/put_test.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+script_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+
+user='admin'
+pass='admin'
+server='localhost:8080'
+
+testfile2="$script_path/zombie.jpg"
+
+curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"
diff --git a/apps/dav/tests/temporary/zombie.jpg b/apps/dav/tests/temporary/zombie.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..4249f1083612b10ea1c63b6f5f3053dd0347f542
GIT binary patch
literal 22014
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
G|0V!*#58jN

literal 0
HcmV?d00001

diff --git a/apps/dav/tests/unit/Files/BundledFileTest.php b/apps/dav/tests/unit/Files/BundledFileTest.php
new file mode 100644
index 000000000000..4e201492e566
--- /dev/null
+++ b/apps/dav/tests/unit/Files/BundledFileTest.php
@@ -0,0 +1,169 @@
+<?php
+/**
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
+ *
+ * @copyright Copyright (c) 2016, ownCloud GmbH.
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+namespace OCA\DAV\Files;
+
+use OC\Files\Storage\Local;
+use OCP\Files\ForbiddenException;
+use Test\HookHelper;
+use OC\Files\Filesystem;
+use OCP\Lock\ILockingProvider;
+
+/**
+ * Class File
+ *
+ * @group DB
+ *
+ * @package OCA\DAV\Tests\unit\Connector\Sabre
+ */
+class BundledFileTest extends \Test\TestCase {
+
+	/**
+	 * @var string
+	 */
+	private $user;
+
+	public function setUp() {
+		parent::setUp();
+
+		\OC_Hook::clear();
+
+		$this->user = $this->getUniqueID('user_');
+		$userManager = \OC::$server->getUserManager();
+		$userManager->createUser($this->user, 'pass');
+
+		$this->loginAsUser($this->user);
+	}
+
+	public function tearDown() {
+		$userManager = \OC::$server->getUserManager();
+		$userManager->get($this->user)->delete();
+		unset($_SERVER['HTTP_OC_CHUNKED']);
+
+		parent::tearDown();
+	}
+
+	private function getMockStorage() {
+		$storage = $this->getMockBuilder('\OCP\Files\Storage')
+			->getMock();
+		$storage->expects($this->any())
+			->method('getId')
+			->will($this->returnValue('home::someuser'));
+		return $storage;
+	}
+
+	/**
+	 * @param string $string
+	 */
+	private function getStream($string) {
+		$stream = fopen('php://temp', 'r+');
+		fwrite($stream, $string);
+		fseek($stream, 0);
+		return $stream;
+	}
+
+//	/**
+//	 * Simulate putting a file to the given path.
+//	 *
+//	 * @param string $path path to put the file into
+//	 * @param string $viewRoot root to use for the view
+//	 *
+//	 * @return null|string of the PUT operaiton which is usually the etag
+//	 */
+//	private function doCreate($path, $fileContents, $viewRoot = null) {
+//		$view = \OC\Files\Filesystem::getView();
+//		if (!is_null($viewRoot)) {
+//			$view = new \OC\Files\View($viewRoot);
+//		} else {
+//			$viewRoot = '/' . $this->user . '/files';
+//		}
+//
+//		$info = new \OC\Files\FileInfo(
+//			$viewRoot . '/' . ltrim($path, '/'),
+//			$this->getMockStorage(),
+//			null,
+//			['permissions' => \OCP\Constants::PERMISSION_ALL],
+//			null
+//		);
+//
+//		$file = new BundledFile($view, $info);
+//
+//		// beforeMethod locks
+//		$view->lockFile($path, ILockingProvider::LOCK_SHARED);
+//
+//		$fileAttributes['content-id'] = 0;
+//		$fileAttributes['x-oc-mtime'] = "1471254375";
+//		$result = $file->createFile($fileContents, $fileAttributes);
+//
+//		// afterMethod unlocks
+//		$view->unlockFile($path, ILockingProvider::LOCK_SHARED);
+//
+//		return $result;
+//	}
+
+	/**
+	 * Simulate putting a file to the given path.
+	 *
+	 * @param string $path path to put the file into
+	 * @param string $viewRoot root to use for the view
+	 *
+	 * @return null|string of the PUT operaiton which is usually the etag
+	 */
+	private function doPut($path, $fileContents, $viewRoot = null) {
+		$view = \OC\Files\Filesystem::getView();
+		if (!is_null($viewRoot)) {
+			$view = new \OC\Files\View($viewRoot);
+		} else {
+			$viewRoot = '/' . $this->user . '/files';
+		}
+
+		$info = new \OC\Files\FileInfo(
+			$viewRoot . '/' . ltrim($path, '/'),
+			$this->getMockStorage(),
+			null,
+			['permissions' => \OCP\Constants::PERMISSION_ALL],
+			null
+		);
+
+		$file = new BundledFile($view, $info);
+
+		// beforeMethod locks
+		$view->lockFile($path, ILockingProvider::LOCK_SHARED);
+
+		$result = $file->put($fileContents);
+
+		// afterMethod unlocks
+		$view->unlockFile($path, ILockingProvider::LOCK_SHARED);
+
+		return $result;
+	}
+
+	/**
+	 * Test putting a single file
+	 * 
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage PUT method not supported for bundling
+	 */
+	public function testThrowPutSingleFile() {
+		$fileContents = $this->getStream('test data');
+		$this->doPut('/foo.txt', $fileContents);
+	}
+}
diff --git a/apps/dav/tests/unit/Files/MultipartContentsParserTest.php b/apps/dav/tests/unit/Files/MultipartContentsParserTest.php
new file mode 100644
index 000000000000..f97765c5bfb8
--- /dev/null
+++ b/apps/dav/tests/unit/Files/MultipartContentsParserTest.php
@@ -0,0 +1,379 @@
+<?php
+/**
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
+ *
+ * @copyright Copyright (c) 2016, ownCloud GmbH.
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+namespace OCA\DAV\Tests\unit\DAV;
+
+use Test\TestCase;
+
+class MultipartContentsParserTest extends TestCase {
+	private $boundrary;
+
+	protected function setUp() {
+		parent::setUp();
+
+		$this->boundrary = 'boundary';
+
+	}
+
+	/**
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Unable to get request content
+	 */
+	public function testGetsThrowWrongContents() {
+		//TODO
+		$bodyStream = "I am not a stream, but pretend to be";
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+
+		$mcp->gets();
+	}
+
+	/**
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Unable to determine headers limit for content part
+	 */
+	public function testReadHeadersThrowEmptyHeader() {
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		$mcp->readHeaders('');
+	}
+
+	/**
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Header of content part contains incorrect headers
+	 */
+	public function testReadHeadersThrowIncorrectHeader() {
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		$mcp->readHeaders("Content-ID: 1\r\nContent-MD5\r\n\r\n");
+	}
+
+	/**
+	 * streamRead function with incorrect parameter
+	 *
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Method streamRead cannot read contents with negative length
+	 */
+	public function testStreamReadToStringThrowNegativeLength() {
+		$bodyContent = 'blabla';
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyContent);
+		//give negative length
+		$multipartContentsParser->streamReadToString(-1);
+	}
+
+	/**
+	 * streamRead function with incorrect parameter
+	 *
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Method streamRead cannot read contents with negative length
+	 */
+	public function testStreamReadToStreamThrowNegativeLength() {
+		$target = fopen('php://temp', 'r+');
+		$bodyContent = 'blabla';
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyContent);
+		//give negative length
+		$multipartContentsParser->streamReadToStream($target,-1);
+	}
+
+	public function testStreamReadToString() {
+		$length = 0;
+		list($multipartContentsParser, $bodyString) = $this->fillMultipartContentsParserStreamWithChars($length);
+		$this->assertEquals($bodyString, $multipartContentsParser->streamReadToString($length));
+
+		$length = 1000;
+		list($multipartContentsParser, $bodyString) = $this->fillMultipartContentsParserStreamWithChars($length);
+		$this->assertEquals($bodyString, $multipartContentsParser->streamReadToString($length));
+
+		$length = 8192;
+		list($multipartContentsParser, $bodyString) = $this->fillMultipartContentsParserStreamWithChars($length);
+		$this->assertEquals($bodyString, $multipartContentsParser->streamReadToString($length));
+
+		$length = 20000;
+		list($multipartContentsParser, $bodyString) = $this->fillMultipartContentsParserStreamWithChars($length);
+		$this->assertEquals($bodyString, $multipartContentsParser->streamReadToString($length));
+	}
+
+	public function testStreamReadToStream() {
+		$length = 0;
+		$this->streamReadToStreamBuilder($length);
+
+		$length = 1000;
+		$this->streamReadToStreamBuilder($length);
+
+		$length = 8192;
+		$this->streamReadToStreamBuilder($length);
+
+		$length = 20000;
+		$this->streamReadToStreamBuilder($length);
+	}
+
+	private function streamReadToStreamBuilder($length) {
+		$target = fopen('php://temp', 'r+');
+		list($multipartContentsParser, $bodyString) = $this->fillMultipartContentsParserStreamWithChars($length);
+		$this->assertEquals(true, $multipartContentsParser->streamReadToStream($target,$length));
+		rewind($target);
+		$this->assertEquals($bodyString, stream_get_contents($target));
+	}
+
+	/**
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage An error appears while reading and parsing header of content part using fgets
+	 */
+	public function testGetPartThrowFailfgets() {
+		$bodyStream = fopen('php://temp', 'r+');
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+
+		$mcp = $this->getMockBuilder('OCA\DAV\Files\MultipartContentsParser')
+			->setConstructorArgs(array($request))
+			->setMethods(array('gets'))
+			->getMock();
+
+		$mcp->expects($this->any())
+			->method('gets')
+			->will($this->onConsecutiveCalls("--boundary\r\n", "Content-ID: 0\r\n", false));
+
+		$mcp->getPartHeaders($this->boundrary);
+	}
+	
+	/**
+	 * If one one the content parts does not contain boundrary, means that received wrong request
+	 *
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Expected boundary delimiter in content part
+	 */
+	public function testGetPartThrowNoBoundraryFound() {
+		// Calling multipletimes getPart on parts without contents should return null,null and signal immedietaly that endDelimiter was reached
+		$bodyFull = "--boundary_wrong\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$multipartContentsParser->getPartHeaders($this->boundrary);
+	}
+
+	/**
+	 *  Reading from request which method getBody returns false
+	 *
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Unable to get request content
+	 */
+	public function testStreamReadThrowWrongBody() {
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn(false);
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		$mcp->getPartHeaders($this->boundrary);
+	}
+
+	/**
+	 *  Reading from request which method getBody returns false
+	 *
+	 */
+	public function testMultipartContentSeekToContentLength() {
+		$bodyStream = fopen('php://temp', 'r+');
+		$bodyString = '';
+		$length = 1000;
+		for ($x = 0; $x < $length; $x++) {
+			$bodyString .= 'k';
+		}
+		fwrite($bodyStream, $bodyString);
+		rewind($bodyStream);
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		$this->assertEquals(true,$mcp->multipartContentSeekToContentLength($length));
+	}
+
+	public function testGetPartWrongBoundaryCases() {
+		// Calling multipletimes getPart on parts without contents should return null and signal immedietaly that endDelimiter was reached
+		$bodyFull = "--boundary\r\n--boundary_wrong\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+	}
+
+	public function testGetPartContents() {
+		// Test empty content
+		$bodyFull = "--boundary\r\n";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$this->assertEquals(null, $multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		// Test empty content
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody('');
+		$this->assertEquals(null, $multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		// Calling multipletimes getPart on parts without contents should return null and signal immedietaly that endDelimiter was reached
+		// endDelimiter should be signaled after first getPart since it will read --boundrary till it finds contents.
+		$bodyFull = "--boundary\r\n--boundary\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		$bodyContent = 'blabla';
+		$bodyFull = '--boundary'
+			."\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
+			."$bodyContent\r\n--boundary";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$headers['content-length'] = '6';
+		$headers['content-type'] = 'application/json; charset=UTF-8';
+		$headers['content-id'] = '0';
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$bodyParsed = $multipartContentsParser->streamReadToString(6);
+		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals($bodyContent, $bodyParsed);
+		$this->assertEquals($headers, $headersParsed);
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$this->assertEquals(null,$headersParsed);
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		// Test First part with content and second without content returning null
+		// The behaviour is motivated by the fact that if there is noting between start content boundrary and the end of multipart boundrary,
+		// it should not raise and error, but simply skip contents returning null and setting endDelimiterReached to true.
+		$bodyContent = 'blabla';
+		$bodyFull = '--boundary'
+			."\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
+			."$bodyContent\r\n--boundary\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$headers['content-length'] = '6';
+		$headers['content-type'] = 'application/json; charset=UTF-8';
+		$headers['content-id'] = '0';
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$bodyParsed = $multipartContentsParser->streamReadToString(6);
+		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals($bodyContent, $bodyParsed);
+		$this->assertEquals($headers, $headersParsed);
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$this->assertEquals(null,$headersParsed);
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		// Test First part without content and second with content, expects that it will just skip the empty boundrary and read the next contents within the same run of getPart
+		// The behaviour is motivated by the fact that iterator at the first boundrary occurence expects next line to be contents and it will iterate till it finds it.
+		// It should set endDelimiterReached to true after next call for header
+		$bodyContent = 'blabla';
+		$bodyFull = '--boundary'
+			."\r\n--boundary\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
+			."$bodyContent\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$headers['content-length'] = '6';
+		$headers['content-type'] = 'application/json; charset=UTF-8';
+		$headers['content-id'] = '0';
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$bodyParsed = $multipartContentsParser->streamReadToString(6);
+		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals($bodyContent, $bodyParsed);
+		$this->assertEquals($headers, $headersParsed);
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$this->assertEquals(null,$headersParsed);
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		// Test First part without content and second with content, expects that it will return first empty string and next will be content
+		$bodyContent = 'blabla';
+		$bodyFull = '--boundary'
+			."\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 0\r\n\r\n"
+			."\r\n--boundary\r\nContent-ID: 1\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
+			."$bodyContent\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+		$headers['content-length'] = '0';
+		$headers['content-type'] = 'application/json; charset=UTF-8';
+		$headers['content-id'] = '0';
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$bodyParsed = $multipartContentsParser->streamReadToString(0);
+		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals("", $bodyParsed);
+		$this->assertEquals($headers, $headersParsed);
+		$headers['content-length'] = '6';
+		$headers['content-type'] = 'application/json; charset=UTF-8';
+		$headers['content-id'] = '1';
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$bodyParsed = $multipartContentsParser->streamReadToString(6);
+		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
+		$this->assertEquals($bodyContent, $bodyParsed);
+		$this->assertEquals($headers, $headersParsed);
+		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
+		$this->assertEquals(null,$headersParsed);
+		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+	}
+
+	private function fillMultipartContentsParserStreamWithChars($length){
+		$bodyStream = fopen('php://temp', 'r+');
+		$bodyString = '';
+		for ($x = 0; $x < $length; $x++) {
+			$bodyString .= 'k';
+		}
+		fwrite($bodyStream, $bodyString);
+		rewind($bodyStream);
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		return array($mcp, $bodyString);
+	}
+
+	private function fillMultipartContentsParserStreamWithBody($bodyString){
+		$bodyStream = fopen('php://temp', 'r+');
+		fwrite($bodyStream, $bodyString);
+		rewind($bodyStream);
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		return $mcp;
+	}
+}

From 6cc3dff5479291d68c52502868c67aaed94cacb5 Mon Sep 17 00:00:00 2001
From: Piotr M <mrow4a@yahoo.com>
Date: Mon, 19 Sep 2016 16:41:56 +0200
Subject: [PATCH 2/4] bundling version 0 beta

---
 apps/dav/lib/Files/BundledFile.php            | 165 ++++----
 apps/dav/lib/Files/BundlingPlugin.php         | 356 +++++++++---------
 .../dav/lib/Files/MultipartContentsParser.php |  15 +-
 apps/dav/tests/temporary/bundling_tests.sh    |  41 +-
 apps/dav/tests/temporary/put_test.sh          |   1 +
 5 files changed, 288 insertions(+), 290 deletions(-)

diff --git a/apps/dav/lib/Files/BundledFile.php b/apps/dav/lib/Files/BundledFile.php
index bb75979c250e..866eb8dd8d3a 100644
--- a/apps/dav/lib/Files/BundledFile.php
+++ b/apps/dav/lib/Files/BundledFile.php
@@ -29,77 +29,96 @@
 use Sabre\DAV\Exception\Forbidden;
 use Sabre\DAV\Exception\ServiceUnavailable;
 use OCA\DAV\Connector\Sabre\File;
+use OCA\DAV\Connector\Sabre\Exception\EntityTooLarge;
+use OCA\DAV\Connector\Sabre\Exception\Forbidden as DAVForbiddenException;
+use OCA\DAV\Connector\Sabre\Exception\UnsupportedMediaType;
+use OCP\Files\ForbiddenException;
+use Sabre\DAV\Exception\BadRequest;
 
 class BundledFile extends File {
 
-	private $partFilePath = null;
-
 	/**
-	 * TODO
+	 * Updates the data
 	 *
-	 * @throws TODO
-	 * @return resource $property
-	 */
-	public function getPartFileResource() {
-		// verify path of the target
-		$this->verifyPath();
-
-		$this->partFilePath = $this->getPartFileBasePath($this->path) . '.ocTransferId' . rand() . '.part';
-
-		// the part file and target file might be on a different storage in case of a single file storage (e.g. single file share)
-		/** @var \OC\Files\Storage\Storage $partStorage */
-		list($partStorage, $internalPartPath) = $this->fileView->resolvePath($this->partFilePath);
-
-		$target = $partStorage->fopen($internalPartPath, 'wb');
-		if ($target === false) {
-			\OCP\Util::writeLog('webdav', '\OC\Files\Filesystem::fopen() failed', \OCP\Util::ERROR);
-				// because we have no clue about the cause we can only throw back a 500/Internal Server Error
-			$this->partFilePath = null;
-			throw new Exception('Could not write file contents');
-		}
-
-		return $target;
-	}
-
-	/**
-	 * TODO
+	 * The $data['data] argument is a readable stream resource.
+	 * The other $data key-values should be header fields in form of string
 	 *
-	 * @return void
-	 */
-	public function unlinkPartFile() {
-		//Prerequisite here is that partFile has to be already existing
-		if ($this->partFilePath != null) {
-			list($partStorage, $internalPartPath) = $this->fileView->resolvePath($this->partFilePath);
-			$partStorage->unlink($internalPartPath);
-		}
-	}
-	/**
-	 * Creates the data
+	 * After a successful put operation, you may choose to return an ETag. The
+	 * etag must always be surrounded by double-quotes. These quotes must
+	 * appear in the actual string you're returning.
+	 *
+	 * Clients may use the ETag from a PUT request to later on make sure that
+	 * when they update the file, the contents haven't changed in the mean
+	 * time.
 	 *
-	 * The data argument is a readable stream
+	 * If you don't plan to store the file byte-by-byte, and you return a
+	 * different object on a subsequent GET you are strongly recommended to not
+	 * return an ETag, and just return null.
 	 *
-	 * @param resource $fileData
-	 * @param array $fileAttributes
+	 * @param array $data
 	 *
-	 * @throws TODO
-	 * @return Array $property
+	 * @throws Forbidden
+	 * @throws UnsupportedMediaType
+	 * @throws BadRequest
+	 * @throws Exception
+	 * @throws EntityTooLarge
+	 * @throws ServiceUnavailable
+	 * @throws FileLocked
+	 * @return array $properties
 	 */
-	public function createFile($fileAttributes) {
-		//Prerequisite here is that partFile has to be already existing
-		if ($this->partFilePath == null) {
-			throw new Forbidden('Part file does not exists, cannot create target file');
+	public function putFile($data) {
+		$properties = array();
+		try {
+			$exists = $this->fileView->file_exists($this->path);
+			if ($this->info && $exists && !$this->info->isUpdateable()) {
+				throw new Forbidden();
+			}
+		} catch (StorageNotAvailableException $e) {
+			throw new ServiceUnavailable("File is not updatable: " . $e->getMessage());
 		}
 
-		$exists = $this->fileView->file_exists($this->path);
-		if ($this->info && $exists) {
-			throw new Forbidden('File does exists, cannot create file');
-		}
 		// verify path of the target
 		$this->verifyPath();
+		
+		$partFilePath = $this->getPartFileBasePath($this->path) . '.ocTransferId' . rand();
 
+		// the part file and target file might be on a different storage in case of a single file storage (e.g. single file share)
+		/** @var \OC\Files\Storage\Storage $partStorage */
+		list($partStorage, $internalPartPath) = $this->fileView->resolvePath($partFilePath);
 		/** @var \OC\Files\Storage\Storage $storage */
 		list($storage, $internalPath) = $this->fileView->resolvePath($this->path);
-		list($partStorage, $internalPartPath) = $this->fileView->resolvePath($this->partFilePath);
+		try {
+			$target = $partStorage->fopen($internalPartPath, 'wb');
+			if ($target === false) {
+				\OCP\Util::writeLog('webdav', '\OC\Files\Filesystem::fopen() failed', \OCP\Util::ERROR);
+				// because we have no clue about the cause we can only throw back a 500/Internal Server Error
+				throw new Exception('Could not write file contents');
+			}
+			list($count, $result) = \OC_Helper::streamCopy($data['data'], $target);
+			fclose($target);
+
+			if ($result === false) {
+				$expected = -1;
+				if (isset($data['content-length'])) {
+					$expected = $data['content-length'];
+				}
+				throw new Exception('Error while copying file to target location (copied bytes: ' . $count . ', expected filesize: ' . $expected . ' )');
+			}
+
+			// if content length is sent by client:
+			// double check if the file was fully received
+			// compare expected and actual size
+			if (isset($data['content-length'])) {
+				$expected = $data['content-length'];
+				if ($count != $expected) {
+					throw new BadRequest('Expected filesize ' . $expected . ' got ' . $count);
+				}
+			}
+
+		} catch (\Exception $e) {
+			$partStorage->unlink($internalPartPath);
+			$this->convertToSabreException($e);
+		}
 
 		try {
 			$view = \OC\Files\Filesystem::getView();
@@ -125,8 +144,10 @@ public function createFile($fileAttributes) {
 					\OCP\Util::writeLog('webdav', 'renaming part file to final file failed', \OCP\Util::ERROR);
 					throw new Exception('Could not rename part file to final file');
 				}
+			} catch (ForbiddenException $ex) {
+				throw new DAVForbiddenException($ex->getMessage(), $ex->getRetry());
 			} catch (\Exception $e) {
-				$this->unlinkPartFile();
+				$partStorage->unlink($internalPartPath);
 				$this->convertToSabreException($e);
 			}
 
@@ -136,40 +157,44 @@ public function createFile($fileAttributes) {
 			try {
 				$this->changeLock(ILockingProvider::LOCK_SHARED);
 			} catch (LockedException $e) {
-				$this->unlinkPartFile();
 				throw new FileLocked($e->getMessage(), $e->getCode(), $e);
 			}
 
 			if ($view) {
 				$this->emitPostHooks($exists);
 			}
-			
+
 			// allow sync clients to send the mtime along in a header
-			if (isset($fileAttributes['x-oc-mtime'])) {
-				if ($this->fileView->touch($this->path, $fileAttributes['x-oc-mtime'])) {
-					$property['{DAV:}x-oc-mtime'] = 'accepted'; //TODO: not sure about that
+			$request = \OC::$server->getRequest();
+			if (isset($data['x-oc-mtime'])) {
+				if ($this->fileView->touch($this->path, $data['x-oc-mtime'])) {
+					$properties['{DAV:}x-oc-mtime'] = 'accepted';
 				}
 			}
 
 			$this->refreshInfo();
 
+			if (isset($data['x-oc-checksum'])) {
+				$checksum = trim($data['x-oc-checksum']);
+				$this->fileView->putFileInfo($this->path, ['checksum' => $checksum]);
+				$this->refreshInfo();
+			} else if ($this->getChecksum() !== null && $this->getChecksum() !== '') {
+				$this->fileView->putFileInfo($this->path, ['checksum' => '']);
+				$this->refreshInfo();
+			}
+
 		} catch (StorageNotAvailableException $e) {
-			$this->unlinkPartFile();
 			throw new ServiceUnavailable("Failed to check file size: " . $e->getMessage());
 		}
 
-		//TODO add proper attributes
 		$etag = $this->getEtag();
-		$property['{DAV:}etag'] = $etag; //TODO: not sure about that
-		$property['{DAV:}oc-etag'] = $etag; //TODO: not sure about that
-		$property['{DAV:}oc-fileid'] = $this->getFileId();//TODO: not sure about that
-		return $property;
+		$properties['{DAV:}etag'] = $etag;
+		$properties['{DAV:}oc-etag'] = $etag;
+		$properties['{DAV:}oc-fileid'] = $this->getFileId();
+		return $properties;
 	}
 
-	/**
-	 *
-	 * TODO: description
-	 *
+	/*
 	 * @param resource $data
 	 *
 	 * @throws Forbidden
diff --git a/apps/dav/lib/Files/BundlingPlugin.php b/apps/dav/lib/Files/BundlingPlugin.php
index a580714b8a95..9f875b9e879b 100644
--- a/apps/dav/lib/Files/BundlingPlugin.php
+++ b/apps/dav/lib/Files/BundlingPlugin.php
@@ -28,9 +28,13 @@
 use Sabre\HTTP\URLUtil;
 use OCP\Lock\ILockingProvider;
 use OC\Files\FileInfo;
-use Sabre\DAV\Exception\Forbidden;
 use Sabre\DAV\Exception\BadRequest;
 use Sabre\DAV\Exception;
+use OCA\DAV\Connector\Sabre\Exception\Forbidden;
+use OCA\DAV\Connector\Sabre\Exception\InvalidPath;
+use OCA\DAV\Connector\Sabre\Exception\FileLocked;
+use OCP\Files\ForbiddenException;
+use OCP\Lock\LockedException;
 
 /**
  * This plugin is responsible for interconnecting three components of the OC server:
@@ -107,7 +111,7 @@ public function initialize(\Sabre\DAV\Server $server) {
 
 		$this->server = $server;
 
-		$server->on('method:POST', array($this, 'handleBundledUpload'));
+		$server->on('method:POST', array($this, 'handleBundle'));
 	}
 
 	/**
@@ -120,75 +124,28 @@ public function initialize(\Sabre\DAV\Server $server) {
 	 * @throws /Sabre\DAV\Exception\Forbidden
 	 * @return null|false
 	 */
-	public function handleBundledUpload(RequestInterface $request, ResponseInterface $response) {
+	public function handleBundle(RequestInterface $request, ResponseInterface $response) {
 		$this->request = $request;
 		$this->response = $response;
 
-		//TODO: add emit (beforeBind)
-
 		//validate the request before parsing
 		$this->validateRequest();
 
-		//TODO: ensure to sign in proper classes to this emit
 		if (!$this->server->emit('beforeWriteBundle', [$this->userFilesHome])){
 			throw new Forbidden('beforeWriteBundle preconditions failed');
 		}
 
 		//Update the content handler of the bundle body
 		$this->contentHandler = $this->getContentHandler($this->request);
-		
-		//Create JSON from metadata content in the bundle
-		$bundleMetadata = $this->getBundleMetadata();
+
+		$multipleRequestsData = $this->parseBundle();
 
 		//Process bundle and send a multistatus response
-		$result = $this->processBundle($bundleMetadata);
+		$result = $this->processBundle($multipleRequestsData);
 
-		//TODO: add emit (afterBind)
-		//TODO: add emit (afterCreateFile)
 		return $result;
 	}
 
-	/**
-	 * Adds to multistatus response exception class string and exception message for specific file
-	 *
-	 * @return void
-	 */
-	protected function handleFileMultiStatusError(&$bundleResponseProperties, $ocPath, $status, $propertyException, $propertyMessage){
-		$entry['href'] = $this->userFilesHome;
-		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}exception'] = $propertyException;
-		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}message'] = $propertyMessage;
-		$entry[$status]['{DAV:}oc-path'] = $ocPath;
-		$bundleResponseProperties[] = $entry;
-	}
-
-	/**
-	 * TODO: description and variables
-	 *
-	 * @return void
-	 */
-	protected function handleFileMultiStatus(&$bundleResponseProperties, $ocPath, $status, $properties){
-		$entry['href'] = $this->userFilesHome;
-		$entry[$status] = $properties;
-		$entry[$status]['{DAV:}oc-path'] = $ocPath;
-		$bundleResponseProperties[] = $entry;
-	}
-
-	/**
-	 * Get content handler
-	 *
-	 * @param  RequestInterface $request
-	 * @param  String $boundary
-	 * @throws TODO: handle exception
-	 * @return array
-	 */
-	protected function getContentHandler(RequestInterface $request) {
-		if ($this->contentHandler === null) {
-			return new MultipartContentsParser($request);
-		}
-			return $this->contentHandler;
-	}
-
-
 	/**
 	 * Check multipart headers.
 	 *
@@ -202,7 +159,7 @@ private function validateRequest() {
 		$this->userFilesHome = $this->request->getPath();
 		$userFilesHomeNode = $this->server->tree->getNodeForPath($this->userFilesHome);
 		if (!($userFilesHomeNode instanceof FilesHome)){
-			throw new BadRequest('URL endpoint has to be instance of \OCA\DAV\Files\FilesHome');
+			throw new Forbidden('URL endpoint has to be instance of \OCA\DAV\Files\FilesHome');
 		}
 
 		$headers = array('Content-Type');
@@ -221,9 +178,8 @@ private function validateRequest() {
 			throw new Forbidden('Improper Content-type format. Boundary may be missing');
 		}
 		$contentType = trim($contentParts[0]);
-		$expectedContentType = 'multipart/related';
+		$expectedContentType = 'multipart/mixed';
 		if ($contentType != $expectedContentType) {
-			//TODO: handle exception
 			throw new BadRequest(sprintf(
 				'Content-Type must be %s',
 				$expectedContentType
@@ -244,168 +200,200 @@ private function validateRequest() {
 	}
 
 	/**
-	 * Get the bundle metadata from the request.
+	 * Parses multipart contents and send appropriete response
 	 *
-	 * Note: MUST be called before getBundleContents, and just one time.
+	 * @throws \Sabre\DAV\Exception\BadRequest
 	 *
-	 * @throws /Sabre\DAV\Exception\BadRequest
-	 * @return array
+	 * @return array $multipleRequestsData
 	 */
-	private function getBundleMetadata() {
-		$metadataContentHeader = $this->contentHandler->getPartHeaders($this->boundary);
-		if (!isset($metadataContentHeader['content-type'])) {
-			throw new BadRequest('Metadata does not contain content-type header');
-		}
-		$expectedContentType = 'application/json';
-		if (substr($metadataContentHeader['content-type'], 0, strlen($expectedContentType)) != $expectedContentType) {
-			throw new BadRequest(sprintf(
-				'Expected content type of first part is %s. Found %s',
-				$expectedContentType,
-				$metadataContentHeader['content-type']
-			));
+	private function parseBundle() {
+		$multipleRequestsData = array();
+		try {
+			while(!$this->contentHandler->getEndDelimiterReached()) {
+				//get multipart header for one of the contents
+				$bundleContent = null;
+				try{
+					$bundleContent = $this->contentHandler->getPartHeaders($this->boundary);
+				}
+				catch (\Exception $e) {
+					throw new \Exception($e->getMessage());
+				}
+
+				if ($bundleContent === null && $this->contentHandler->getEndDelimiterReached()){
+					//endDelimiter reached, break
+					break;
+				}
+
+				//process X-OC-Path
+				if (!isset($bundleContent['x-oc-path'])){
+					//without oc-path we cannot contruct multistatus response
+					throw new \Exception('File header does not contain X-OC-Path. Unable to parse whole bundle request');
+				}
+
+				if (!isset($bundleContent['x-oc-method'])) {
+					throw new \Exception('File ['.$bundleContent['x-oc-path'].'] metadata does not contain required key - value pair containing x-oc-method');
+				}
+
+				switch(strtolower($bundleContent['x-oc-method'])){
+					case 'put':
+
+						if (!isset($bundleContent['content-length'])) {
+							throw new \Exception('File ['.$bundleContent['x-oc-path'].'] header does not contain Content-Length. Unable to parse whole bundle request');
+						}
+
+						//create a in-memory file
+						$target = fopen('php://memory', "rw+");
+						if (!$this->contentHandler->streamReadToStream($target, $bundleContent['content-length'])){
+							fclose($target);
+							throw new \Exception('Error reading the file contents ['.$bundleContent['x-oc-path'].']');
+						}
+						rewind($target);
+						$bundleContent['data'] = $target;
+						break;
+					default:
+						throw new \Exception('Method '.$bundleContent['x-oc-method'].' not supported - ['.$bundleContent['x-oc-path'].']');
+						break;
+				}
+				$multipleRequestsData[] = $bundleContent;
+			}
+		} catch (\Exception $e) {
+			//cleanup the $multipleRequestsData and throw exception
+			foreach ($multipleRequestsData as $bundleContent){
+				if (isset($bundleContent['data']) && is_resource($bundleContent['data'])){
+					fclose($bundleContent['data']);
+				}
+			}
+			throw new BadRequest($e->getMessage());
 		}
+		return $multipleRequestsData;
+	}
 
-		if (!isset($metadataContentHeader['content-length'])) {
-			throw new BadRequest('Metadata does not contain content-length header');
-		}
+	/**
+	 * Process multipart contents and send appropriete response
+	 *
+	 * @param  RequestInterface $request
+	 *
+	 * @return boolean
+	 */
+	private function processBundle($multipleRequestsData) {
+		$bundleResponseProperties = array();
+
+		foreach($multipleRequestsData as $requestData) {
+			//TODO: here should be x-oc-method switch again
 
-		$metaDataContent = $this->contentHandler->streamReadToString($metadataContentHeader['content-length']);
-
-		if (isset($metadataContentHeader['content-md5'])) {
-			//check if the expected metadata is corrupted
-			$contentMD5 = $metadataContentHeader['content-md5'];
-			$hash = md5($metaDataContent);
-			if (!($hash === $contentMD5)) {
-				throw new BadRequest(sprintf(
-					'Received wrong metadata. Expected Content-MD5 %s, expected %s',
-					$contentMD5,
-					$hash
-				));
+			//parseBundle function ensures that PUT only will pass
+			if (isset($requestData['data']) && is_resource($requestData['data'])){
+				$bundleResponseProperties[] = $this->processPutFile($requestData);
+				fclose($requestData['data']);
 			}
 		}
 
-		//rewind to the begining of file for streamCopy and copy stream
-		$jsonContent = json_decode($metaDataContent, true);
-		if ($jsonContent === null) {
-			throw new BadRequest('Unable to parse JSON');
-		}
+		//multistatus response anounced
+		$this->response->setHeader('Content-Type', 'application/xml; charset=utf-8');
+		$this->response->setStatus(207);
+		$data = $this->server->generateMultiStatus($bundleResponseProperties);
+		$this->response->setBody($data);
 
-		return $jsonContent;
+		return false;
 	}
 
 	/**
 	 * Process multipart contents and send appropriete response
 	 *
+	 * @param  RequestInterface $request
+	 *
 	 * @return boolean
 	 */
-	private function processBundle($bundleMetadata) {
-		$bundleResponseProperties = array();
+	private function processPutFile($requestData) {
+		//parseBundle function ensures that PUT has X-OC-PATH, otherwise request will fail earlier.
+		$filePath = $requestData['x-oc-path'];
 
-		while(!$this->contentHandler->getEndDelimiterReached()) {
-			//get multipart header for one of the contents
-			try{
-				$bundleContentHeader = $this->contentHandler->getPartHeaders($this->boundary);
-			}
-			catch (Exception $e) {
-				throw new BadRequest($e->getMessage());
-			}
+		if ($this->server->tree->nodeExists($filePath)) {
+			$exc = new BadRequest('Method not allowed - file exists - update of the file is not supported!');
+			return $this->handleFileMultiStatusError( $filePath, $exc);
+		}
 
-			if ($bundleContentHeader === null && $this->contentHandler->getEndDelimiterReached()){
-				//endDelimiter reached, break
-				break;
-			}
+		list($folderPath, $fileName) = URLUtil::splitPath($filePath);
 
-			if (!isset($bundleContentHeader['content-length'])) {
-				throw new BadRequest('File header does not contain Content-Length. Unable to parse whole bundle request');
-			}
-			
-			if (!isset($bundleContentHeader['content-id'])) {
-				//part is multipart/related, but header contains too less data to create file or signilizes EndDelimiterReached, ignore
-				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);
-				continue;
-			}
-			
-			//try to match content part header to bundleMetadata for that bundleContent
-			$binaryID = $bundleContentHeader['content-id'];
-			if (!isset($bundleMetadata[$binaryID])){
-				//part is multipart/related, but content-id in header does not match any of the files
-				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);
-				continue;
-			}
-			$fileAttributes = $bundleMetadata[$binaryID];
+		if ($folderPath === ''){
+			$fullFolderPath = $this->userFilesHome;
+		}
+		else{
+			$fullFolderPath = $this->userFilesHome . '/' . $folderPath;
+		}
 
-			//process oc-path
-			if (!isset($fileAttributes['oc-path'])){
-				//without oc-path we cannot contruct multistatus response
-				throw new BadRequest('File metadata does not contain required key - value pair containing oc-path');
-			}
+		// For non-chunked upload it is enough to check if we can create a new file in a parent folder
+		if (!isset($this->cacheValidParents[$folderPath])){
+			$this->cacheValidParents[$folderPath] = ($this->server->tree->nodeExists($fullFolderPath) && $this->fileView->isCreatable($folderPath));
+		}
 
-			//get oc-path of the file
-			$filePath = $fileAttributes['oc-path'];
-			list($folderPath, $fileName) = URLUtil::splitPath($filePath);
+		if (!$this->cacheValidParents[$folderPath]) {
+			$exc = new BadRequest('File creation on not existing or without creation permission parent folder is not permitted');
+			return $this->handleFileMultiStatusError($filePath, $exc);
+		}
 
-			if ($folderPath === ''){
-				$fullFolderPath = $this->userFilesHome;
-			}
-			else{
-				$fullFolderPath = $this->userFilesHome . '/' . $folderPath;
-			}
 
-			//validate parent folder
-			if (!isset($this->cacheValidParents[$folderPath])){
-				$this->cacheValidParents[$folderPath] = ($this->server->tree->nodeExists($fullFolderPath) && $this->fileView->isCreatable($folderPath));
+		try {
+			# the check here is necessary, because createFile uses put covered in sabre/file.php
+			# and not touch covered in files/view.php
+			if (\OC\Files\Filesystem::isForbiddenFileOrDir($fileName)) {
+				throw new \Sabre\DAV\Exception\Forbidden();
 			}
 
-			if (!$this->cacheValidParents[$folderPath]) {
-				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);	
-				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', 'File creation on not existing or without creation permission parent folder is not permitted');
-				continue;
-			}
+			$this->fileView->verifyPath($folderPath, $fileName);
 
 			//get absolute path of the file
 			$absoluteFilePath = $this->fileView->getAbsolutePath($folderPath) . '/' . $fileName;
 			$info = new FileInfo($absoluteFilePath, null, null, array(), null);
 			$node = new BundledFile($this->fileView, $info);
+			$node->acquireLock(ILockingProvider::LOCK_SHARED);
+			$properties = $node->putFile($requestData);
+		} catch (\Exception $exc) {
+			return $this->handleFileMultiStatusError($filePath, $exc);
+		}
 
-			try{
-				$target = $node->getPartFileResource();
-			} catch (\Exception $e) {
-				$this->contentHandler->multipartContentSeekToContentLength($bundleContentHeader['content-length']);
-				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', $e->getMessage());
-				continue;
-			}
-			
-			if (!$this->contentHandler->streamReadToStream($target, $bundleContentHeader['content-length'])){
-				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', 'Error reading the file contents');
-			}
-			fclose($target);
-
-			try{
-				$node->acquireLock(ILockingProvider::LOCK_SHARED);
-			} catch (\Exception $e) {
-				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', $e->getMessage());
-				continue;
-			}
+		//release lock as in dav/lib/Connector/Sabre/LockPlugin.php
+		$node->releaseLock(ILockingProvider::LOCK_SHARED);
+		$this->server->tree->markDirty($filePath);
+		return $this->handleFileMultiStatus($filePath, $properties);
+	}
+	
+	/**
+	 * Adds to multistatus response exception class string and exception message for specific file
+	 *
+	 * @return array $entry
+	 */
+	protected function handleFileMultiStatusError($ocPath, $exc){
+		$status = $exc->getHTTPCode();
+		$entry['href'] = $this->userFilesHome;
+		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}exception'] = get_class($exc);
+		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}message'] = $exc->getMessage();
+		$entry[$status]['{DAV:}oc-path'] = $ocPath;
+		return $entry;
+	}
 
-			try{
-				$properties = $node->createFile($fileAttributes);
-			} catch (\Exception $e) {
-				$node->releaseLock(ILockingProvider::LOCK_SHARED);
-				$this->handleFileMultiStatusError($bundleResponseProperties, $filePath, 400, 'Sabre\DAV\Exception\BadRequest', $e->getMessage());
-				continue;
-			}
+	/**
+	 * Adds to multistatus response properties for specific file
+	 *
+	 * @return array $entry
+	 */
+	protected function handleFileMultiStatus($ocPath, $properties){
+		$entry['href'] = $this->userFilesHome;
+		$entry[200] = $properties;
+		$entry[200]['{DAV:}oc-path'] = $ocPath;
+		return $entry;
+	}
 
-			$node->releaseLock(ILockingProvider::LOCK_SHARED);
-			$this->server->tree->markDirty($filePath);
-			$this->handleFileMultiStatus($bundleResponseProperties, $filePath, 200, $properties);
+	/**
+	 * Get content handler
+	 *
+	 * @param  RequestInterface $request
+	 * @return \OCA\DAV\Files\MultipartContentsParser
+	 */
+	protected function getContentHandler(RequestInterface $request) {
+		if ($this->contentHandler === null) {
+			return new MultipartContentsParser($request);
 		}
-
-		//multistatus response anounced
-		$this->response->setHeader('Content-Type', 'application/xml; charset=utf-8');
-		$this->response->setStatus(207);
-		$data = $this->server->generateMultiStatus($bundleResponseProperties);
-		$this->response->setBody($data);
-
-		return false;
+		return $this->contentHandler;
 	}
 }
\ No newline at end of file
diff --git a/apps/dav/lib/Files/MultipartContentsParser.php b/apps/dav/lib/Files/MultipartContentsParser.php
index 53299e071563..b0994d8c0dd0 100644
--- a/apps/dav/lib/Files/MultipartContentsParser.php
+++ b/apps/dav/lib/Files/MultipartContentsParser.php
@@ -131,7 +131,7 @@ public function getContent() {
      *
      * @param  String $boundary
      *
-     * @throws \Sabre\DAV\Exception\BadRequest
+     * @throws \Exception
      * @return array (array $headers, resource $bodyStream)
      */
     public function getPartHeaders($boundary) {
@@ -150,14 +150,14 @@ public function getPartHeaders($boundary) {
                     break;
                 }
                 else{
-                    throw new BadRequest('An error appears while reading and parsing header of content part using fgets');
+                    throw new \Exception('An error appears while reading and parsing header of content part using fgets');
                 }
             }
 
             if ($boundaryCount == 0) {
                 if ($line != $delimiter) {
                     if ($this->getCursor() == strlen($line)) {
-                        throw new BadRequest('Expected boundary delimiter in content part - not a multipart/related request');
+                        throw new \Exception('Expected boundary delimiter in content part - this is not a multipart request');
                     }
                     elseif ($line == $endDelimiter || $line == $endDelimiter."\r\n") {
                         $this->endDelimiterReached = true;
@@ -262,20 +262,21 @@ public function streamReadToStream($target, $length) {
      *
      * @param string $content
      * 
-     * @throws \Sabre\DAV\Exception\BadRequest
      * @return Array $headers
      */
     public function readHeaders($content) {
+        $headers = null;
         $headerLimitation = strpos($content, "\r\n\r\n");
         if ($headerLimitation === false) {
-            throw new BadRequest('Unable to determine headers limit for content part');
+            return null;
         }
         $headersContent = substr($content, 0, $headerLimitation);
         $headersContent = trim($headersContent);
         foreach (explode("\r\n", $headersContent) as $header) {
-            $parts = explode(':', $header);
+            $parts = explode(':', $header, 2);
             if (count($parts) != 2) {
-                throw new BadRequest('Header of content part contains incorrect headers');
+                //has incorrect header, try to continue
+                continue;
             }
             $headers[strtolower(trim($parts[0]))] = trim($parts[1]);
         }
diff --git a/apps/dav/tests/temporary/bundling_tests.sh b/apps/dav/tests/temporary/bundling_tests.sh
index 1519e4154899..5e581336c3dd 100755
--- a/apps/dav/tests/temporary/bundling_tests.sh
+++ b/apps/dav/tests/temporary/bundling_tests.sh
@@ -6,25 +6,11 @@ user='admin'
 pass='admin'
 server='localhost:8080'
 upload="/tmp/upload.txt"
-header="/tmp/header.json"
-
-echo -en "{
-  \"1\": {
-    \"oc-path\":\"bundling_tests.sh\",
-    \"x-oc-mtime\":\"1471254375\"
-  },
-  \"2\": {
-    \"oc-path\":\"test/zombie1.jpg\",
-    \"x-oc-mtime\":\"1471254375\"
-  },
-  \"3\": {
-    \"oc-path\":\"test/zombie2.jpg\",
-    \"x-oc-mtime\":\"1471254375\"
-  }
-}" > $header
-
-size0=$(du -sb $header | awk '{ print $1 }')
-md50=$(md5sum $header | awk '{ print $1 }')
+
+testfile0="/tmp/test.txt"
+echo -en "abcd" > $testfile0
+size0=$(du -sb $testfile0 | awk '{ print $1 }')
+md50=$(md5sum $testfile0 | awk '{ print $1 }')
 
 testfile1="$script_path/bundling_tests.sh"
 size1=$(du -sb $testfile1 | awk '{ print $1 }')
@@ -37,26 +23,23 @@ md52=$(md5sum $testfile2 | awk '{ print $1 }')
 mdupload=$(md5sum $upload | awk '{ print $1 }')
 boundrary="boundary_$mdupload"
 
-#METADATA
-echo -en "--$boundrary\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: $size0\r\nContent-MD5: $md50\r\n\r\n" > $upload
-cat $header >> $upload
-
 #CONTENTS
-echo -en "\r\n--$boundrary\r\nContent-ID: 1\r\nContent-length: 4\r\n\r\nabcd" >> $upload
-
-echo -en "\r\n--$boundrary\r\nContent-ID: 2\r\nContent-length: $size2\r\nContent-MD5: $md52\r\n\r\n" >> $upload
-cat $testfile2 >> $upload
+echo -en "--$boundrary\r\nX-OC-Method: PUT\r\nX-OC-Path: test/test.txt\r\nX-OC-Mtime: 1471254375\r\nContent-length: $size0\r\nContent-MD5: $md50\r\n\r\n" > $upload
+cat $testfile0 >> $upload
 
-echo -en "\r\n--$boundrary\r\nContent-ID: 3\r\nContent-length: $size1\r\nContent-MD5: $md51\r\n\r\n" >> $upload
+echo -en "\r\n--$boundrary\r\nX-OC-Method: PUT\r\nX-OC-Path: bundling_tests.sh\r\nX-OC-Mtime: 1471254475\r\nContent-length: $size1\r\nContent-MD5: $md51\r\n\r\n" >> $upload
 cat $testfile1 >> $upload
 
+echo -en "\r\n--$boundrary\r\nX-OC-Method: PUT\r\nX-OC-Path: test/zombie1.jpg\r\nX-OC-Mtime: 1471254275\r\nContent-length: $size2\r\nContent-MD5: $md52\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
 #END BOUNDRARY
 echo -en "\r\n--$boundrary--\r\n" >> $upload
 
 #POST
 #curl -X DELETE -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" "http://$server/remote.php/webdav/config.cfg"
 
-curl -X POST -H "Content-Type: multipart/related; boundary=$boundrary" --cookie "XDEBUG_SESSION=MROW4A;path=/;" \
+curl -X POST -H "Content-Type: multipart/mixed; boundary=$boundrary" --cookie "XDEBUG_SESSION=MROW4A;path=/;" \
     --data-binary "@$upload" \
     "http://$user:$pass@$server/remote.php/dav/files/$user"
 
diff --git a/apps/dav/tests/temporary/put_test.sh b/apps/dav/tests/temporary/put_test.sh
index 40b14ee833d5..ca111f3083a9 100755
--- a/apps/dav/tests/temporary/put_test.sh
+++ b/apps/dav/tests/temporary/put_test.sh
@@ -8,4 +8,5 @@ server='localhost:8080'
 
 testfile2="$script_path/zombie.jpg"
 
+#blackfire --samples 1 curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"
 curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"

From e3273143c6cf6e5a2f5731c769088c264be703ec Mon Sep 17 00:00:00 2001
From: Piotr M <mrow4a@yahoo.com>
Date: Wed, 16 Nov 2016 00:53:08 +0100
Subject: [PATCH 3/4] implementation of bundling plugin - multipart/related
 with unit tests

---
 apps/dav/lib/Capabilities.php                 |   6 +-
 apps/dav/lib/Files/BundledFile.php            |  55 ++--
 apps/dav/lib/Files/BundlingPlugin.php         | 244 ++++++++++--------
 .../dav/lib/Files/MultipartContentsParser.php |  17 +-
 apps/dav/tests/temporary/bundling_profile.sh  | 149 +++++++++++
 apps/dav/tests/temporary/bundling_tests.sh    |  41 ++-
 apps/dav/tests/temporary/put_test.sh          |   6 +-
 apps/dav/tests/unit/Files/BundledFileTest.php | 151 +++++++----
 .../Files/MultipartContentsParserTest.php     | 174 ++++++++-----
 9 files changed, 563 insertions(+), 280 deletions(-)
 create mode 100755 apps/dav/tests/temporary/bundling_profile.sh

diff --git a/apps/dav/lib/Capabilities.php b/apps/dav/lib/Capabilities.php
index 3f764fd29543..5339a17deccd 100644
--- a/apps/dav/lib/Capabilities.php
+++ b/apps/dav/lib/Capabilities.php
@@ -1,9 +1,9 @@
 <?php
 /**\
- * @author Thomas Müller <thomas.mueller@tmit.eu>\
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
  * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
  *
- * @copyright Copyright (c) 2016, ownCloud GmbH.\
+ * @copyright Copyright (c) 2016, ownCloud GmbH
  * @license AGPL-3.0
  *
  * This code is free software: you can redistribute it and/or modify
@@ -31,7 +31,7 @@ public function getCapabilities() {
 		return [
 			'dav' => [
 				'chunking' => '1.0',
-				'bundlerequest' => true,
+				'bundlerequest' => '1.0',
 			]
 		];
 	}
diff --git a/apps/dav/lib/Files/BundledFile.php b/apps/dav/lib/Files/BundledFile.php
index 866eb8dd8d3a..8ecb92616b26 100644
--- a/apps/dav/lib/Files/BundledFile.php
+++ b/apps/dav/lib/Files/BundledFile.php
@@ -37,6 +37,19 @@
 
 class BundledFile extends File {
 
+
+	/**
+	 * This class is a wrapper around the bundled request body and provides access to its contents
+	 *
+	 * @var \OCA\DAV\Files\MultipartContentsParser
+	 *
+	 */
+	private $contentHandler;
+
+	public function __construct($view, $info, $contentHandler){
+		$this->contentHandler = $contentHandler;
+		parent::__construct($view, $info);
+	}
 	/**
 	 * Updates the data
 	 *
@@ -70,16 +83,22 @@ public function putFile($data) {
 		$properties = array();
 		try {
 			$exists = $this->fileView->file_exists($this->path);
-			if ($this->info && $exists && !$this->info->isUpdateable()) {
-				throw new Forbidden();
+			if ($this->info && $exists) {
+				throw new Forbidden('Bundling not supported for already existing files');
 			}
 		} catch (StorageNotAvailableException $e) {
 			throw new ServiceUnavailable("File is not updatable: " . $e->getMessage());
 		}
 
+		if (!isset($data['oc-total-length'])) {
+			//this should not happen, since upper layer takes care of that
+			//Thus, return Forbidden as sign of code inconsistency
+			throw new Forbidden('File requires oc-total-length header to be read');
+		}
+
 		// verify path of the target
 		$this->verifyPath();
-		
+
 		$partFilePath = $this->getPartFileBasePath($this->path) . '.ocTransferId' . rand();
 
 		// the part file and target file might be on a different storage in case of a single file storage (e.g. single file share)
@@ -94,25 +113,11 @@ public function putFile($data) {
 				// because we have no clue about the cause we can only throw back a 500/Internal Server Error
 				throw new Exception('Could not write file contents');
 			}
-			list($count, $result) = \OC_Helper::streamCopy($data['data'], $target);
-			fclose($target);
 
-			if ($result === false) {
-				$expected = -1;
-				if (isset($data['content-length'])) {
-					$expected = $data['content-length'];
-				}
-				throw new Exception('Error while copying file to target location (copied bytes: ' . $count . ', expected filesize: ' . $expected . ' )');
-			}
+			$result = $this->contentHandler->streamReadToStream($target, $data['oc-total-length']);
 
-			// if content length is sent by client:
-			// double check if the file was fully received
-			// compare expected and actual size
-			if (isset($data['content-length'])) {
-				$expected = $data['content-length'];
-				if ($count != $expected) {
-					throw new BadRequest('Expected filesize ' . $expected . ' got ' . $count);
-				}
+			if ($result === false) {
+				throw new Exception('Error while copying file to target location (expected filesize: ' . $data['oc-total-length'] . ' )');
 			}
 
 		} catch (\Exception $e) {
@@ -166,16 +171,16 @@ public function putFile($data) {
 
 			// allow sync clients to send the mtime along in a header
 			$request = \OC::$server->getRequest();
-			if (isset($data['x-oc-mtime'])) {
-				if ($this->fileView->touch($this->path, $data['x-oc-mtime'])) {
-					$properties['{DAV:}x-oc-mtime'] = 'accepted';
+			if (isset($data['oc-mtime'])) {
+				if ($this->fileView->touch($this->path, $data['oc-mtime'])) {
+					$properties['{DAV:}oc-mtime'] = 'accepted';
 				}
 			}
 
 			$this->refreshInfo();
 
-			if (isset($data['x-oc-checksum'])) {
-				$checksum = trim($data['x-oc-checksum']);
+			if (isset($data['oc-checksum'])) {
+				$checksum = trim($data['oc-checksum']);
 				$this->fileView->putFileInfo($this->path, ['checksum' => $checksum]);
 				$this->refreshInfo();
 			} else if ($this->getChecksum() !== null && $this->getChecksum() !== '') {
diff --git a/apps/dav/lib/Files/BundlingPlugin.php b/apps/dav/lib/Files/BundlingPlugin.php
index 9f875b9e879b..9cd655765500 100644
--- a/apps/dav/lib/Files/BundlingPlugin.php
+++ b/apps/dav/lib/Files/BundlingPlugin.php
@@ -138,7 +138,7 @@ public function handleBundle(RequestInterface $request, ResponseInterface $respo
 		//Update the content handler of the bundle body
 		$this->contentHandler = $this->getContentHandler($this->request);
 
-		$multipleRequestsData = $this->parseBundle();
+		$multipleRequestsData = $this->parseBundleHeader();
 
 		//Process bundle and send a multistatus response
 		$result = $this->processBundle($multipleRequestsData);
@@ -178,7 +178,7 @@ private function validateRequest() {
 			throw new Forbidden('Improper Content-type format. Boundary may be missing');
 		}
 		$contentType = trim($contentParts[0]);
-		$expectedContentType = 'multipart/mixed';
+		$expectedContentType = 'multipart/related';
 		if ($contentType != $expectedContentType) {
 			throw new BadRequest(sprintf(
 				'Content-Type must be %s',
@@ -206,63 +206,69 @@ private function validateRequest() {
 	 *
 	 * @return array $multipleRequestsData
 	 */
-	private function parseBundle() {
+	private function parseBundleHeader() {
 		$multipleRequestsData = array();
 		try {
-			while(!$this->contentHandler->getEndDelimiterReached()) {
-				//get multipart header for one of the contents
-				$bundleContent = null;
-				try{
-					$bundleContent = $this->contentHandler->getPartHeaders($this->boundary);
-				}
-				catch (\Exception $e) {
-					throw new \Exception($e->getMessage());
-				}
+			//get multipart header for one of the contents
+			if ($this->contentHandler->getEndDelimiterReached()){
+				//endDelimiter reached, break
+				return $multipleRequestsData;
+			}
 
-				if ($bundleContent === null && $this->contentHandler->getEndDelimiterReached()){
-					//endDelimiter reached, break
-					break;
-				}
+			// Verify metadata part headers
+			$bundleMetadata = null;
+			try{
+				$bundleMetadata = $this->contentHandler->getPartHeaders($this->boundary);
+			}
+			catch (\Exception $e) {
+				throw new \Exception($e->getMessage());
+			}
+			$contentParts = explode(';', $bundleMetadata['content-type']);
+			if (count($contentParts) != 2) {
+				throw new \Exception('Incorrect Content-type format. Charset might be missing');
+			}
+			$contentType = trim($contentParts[0]);
+			$expectedContentType = 'text/xml';
+			if ($contentType != $expectedContentType) {
+				throw new BadRequest(sprintf(
+					'Content-Type must be %s',
+					$expectedContentType
+				));
+			}
+			if (!isset($bundleMetadata['content-length'])) {
+				throw new \Exception('Bundle metadata header does not contain Content-Length. Unable to parse whole bundle request');
+			}
 
-				//process X-OC-Path
-				if (!isset($bundleContent['x-oc-path'])){
-					//without oc-path we cannot contruct multistatus response
-					throw new \Exception('File header does not contain X-OC-Path. Unable to parse whole bundle request');
-				}
+			// Read metadata part headers
+			$bundleMetadataBody = $this->contentHandler->streamReadToString($bundleMetadata['content-length']);
 
-				if (!isset($bundleContent['x-oc-method'])) {
-					throw new \Exception('File ['.$bundleContent['x-oc-path'].'] metadata does not contain required key - value pair containing x-oc-method');
-				}
+			$bundleMetadataBody = preg_replace("/xmlns(:[A-Za-z0-9_])?=(\"|\')DAV:(\"|\')/","xmlns\\1=\"urn:DAV\"",$bundleMetadataBody);
+			$xml = simplexml_load_string($bundleMetadataBody);
+			unset($bundleMetadataBody);
+			$xml->registerXPathNamespace('d','urn:DAV');
 
-				switch(strtolower($bundleContent['x-oc-method'])){
-					case 'put':
-
-						if (!isset($bundleContent['content-length'])) {
-							throw new \Exception('File ['.$bundleContent['x-oc-path'].'] header does not contain Content-Length. Unable to parse whole bundle request');
-						}
-
-						//create a in-memory file
-						$target = fopen('php://memory', "rw+");
-						if (!$this->contentHandler->streamReadToStream($target, $bundleContent['content-length'])){
-							fclose($target);
-							throw new \Exception('Error reading the file contents ['.$bundleContent['x-oc-path'].']');
-						}
-						rewind($target);
-						$bundleContent['data'] = $target;
-						break;
-					default:
-						throw new \Exception('Method '.$bundleContent['x-oc-method'].' not supported - ['.$bundleContent['x-oc-path'].']');
-						break;
-				}
-				$multipleRequestsData[] = $bundleContent;
+			if(1 != count($xml->xpath('/d:multipart'))){
+				throw new \Exception('Bundle metadata does not contain d:multipart children element. Unable to parse whole bundle request');
 			}
-		} catch (\Exception $e) {
-			//cleanup the $multipleRequestsData and throw exception
-			foreach ($multipleRequestsData as $bundleContent){
-				if (isset($bundleContent['data']) && is_resource($bundleContent['data'])){
-					fclose($bundleContent['data']);
+
+			foreach ($xml->xpath('/d:multipart/d:part/d:prop') as $prop) {
+				$fileMetadata = get_object_vars($prop->children('d', TRUE));
+				$headers = array('oc-path', 'oc-mtime', 'oc-id', 'oc-total-length');
+				foreach ($headers as $header) {
+					if (in_array($header,$fileMetadata) && (count($fileMetadata->{$header} == 1))) {
+						throw new \Exception($header.' header is needed in the bundle metadata for each file. Unable to parse whole bundle request');
+					}
 				}
+				$contentID = intval($fileMetadata['oc-id']);
+				if(array_key_exists($contentID, $multipleRequestsData)){
+					throw new \Exception('One or more files have the same Content-ID '.$contentID.'. Unable to parse whole bundle request');
+				}
+				$multipleRequestsData[$contentID]['oc-path'] = $fileMetadata['oc-path'];
+				$multipleRequestsData[$contentID]['oc-mtime'] = $fileMetadata['oc-mtime'];
+				$multipleRequestsData[$contentID]['oc-total-length'] = intval($fileMetadata['oc-total-length']);
+				$multipleRequestsData[$contentID]['response'] = null;
 			}
+		} catch (\Exception $e) {
 			throw new BadRequest($e->getMessage());
 		}
 		return $multipleRequestsData;
@@ -278,86 +284,98 @@ private function parseBundle() {
 	private function processBundle($multipleRequestsData) {
 		$bundleResponseProperties = array();
 
-		foreach($multipleRequestsData as $requestData) {
-			//TODO: here should be x-oc-method switch again
+		while(!$this->contentHandler->getEndDelimiterReached()) {
+			// Verify metadata part headers
+			$fileContentHeader = null;
 
-			//parseBundle function ensures that PUT only will pass
-			if (isset($requestData['data']) && is_resource($requestData['data'])){
-				$bundleResponseProperties[] = $this->processPutFile($requestData);
-				fclose($requestData['data']);
+			//If something fails at this point, just continue, $multipleRequestsData[$contentID]['response'] will be null for this content
+			try{
+				$fileContentHeader = $this->contentHandler->getPartHeaders($this->boundary);
+				if(is_null($fileContentHeader) || !isset($fileContentHeader['content-id']) || !array_key_exists(intval($fileContentHeader['content-id']), $multipleRequestsData)){
+					continue;
+				}
+			}
+			catch (\Exception $e) {
+				continue;
 			}
-		}
 
-		//multistatus response anounced
-		$this->response->setHeader('Content-Type', 'application/xml; charset=utf-8');
-		$this->response->setStatus(207);
-		$data = $this->server->generateMultiStatus($bundleResponseProperties);
-		$this->response->setBody($data);
+			$fileID = intval($fileContentHeader['content-id']);
+			$fileMetadata = $multipleRequestsData[$fileID];
 
-		return false;
-	}
+			$filePath = $fileMetadata['oc-path'];
 
-	/**
-	 * Process multipart contents and send appropriete response
-	 *
-	 * @param  RequestInterface $request
-	 *
-	 * @return boolean
-	 */
-	private function processPutFile($requestData) {
-		//parseBundle function ensures that PUT has X-OC-PATH, otherwise request will fail earlier.
-		$filePath = $requestData['x-oc-path'];
-
-		if ($this->server->tree->nodeExists($filePath)) {
-			$exc = new BadRequest('Method not allowed - file exists - update of the file is not supported!');
-			return $this->handleFileMultiStatusError( $filePath, $exc);
-		}
+			if ($this->server->tree->nodeExists($filePath)) {
+				//set error response for that object
+				$exc = new BadRequest('Method not allowed - file exists - update of the file is not supported!');
+				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatusError($filePath, $exc);
+				continue;
+			}
 
-		list($folderPath, $fileName) = URLUtil::splitPath($filePath);
+			list($folderPath, $fileName) = URLUtil::splitPath($filePath);
 
-		if ($folderPath === ''){
-			$fullFolderPath = $this->userFilesHome;
-		}
-		else{
-			$fullFolderPath = $this->userFilesHome . '/' . $folderPath;
-		}
+			if ($folderPath === ''){
+				$fullFolderPath = $this->userFilesHome;
+			}
+			else{
+				$fullFolderPath = $this->userFilesHome . '/' . $folderPath;
+			}
 
-		// For non-chunked upload it is enough to check if we can create a new file in a parent folder
-		if (!isset($this->cacheValidParents[$folderPath])){
-			$this->cacheValidParents[$folderPath] = ($this->server->tree->nodeExists($fullFolderPath) && $this->fileView->isCreatable($folderPath));
-		}
+			// For non-chunked upload it is enough to check if we can create a new file in a parent folder
+			if (!isset($this->cacheValidParents[$folderPath])){
+				$this->cacheValidParents[$folderPath] = ($this->server->tree->nodeExists($fullFolderPath) && $this->fileView->isCreatable($folderPath));
+			}
 
-		if (!$this->cacheValidParents[$folderPath]) {
-			$exc = new BadRequest('File creation on not existing or without creation permission parent folder is not permitted');
-			return $this->handleFileMultiStatusError($filePath, $exc);
-		}
+			if (!$this->cacheValidParents[$folderPath]) {
+				$exc = new BadRequest('File creation on not existing or without creation permission parent folder is not permitted');
+				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatusError($filePath, $exc);
+				continue;
+			}
 
+			try {
+				# the check here is necessary, because createFile uses put covered in sabre/file.php
+				# and not touch covered in files/view.php
+				if (\OC\Files\Filesystem::isForbiddenFileOrDir($fileName)) {
+					throw new \Sabre\DAV\Exception\Forbidden();
+				}
 
-		try {
-			# the check here is necessary, because createFile uses put covered in sabre/file.php
-			# and not touch covered in files/view.php
-			if (\OC\Files\Filesystem::isForbiddenFileOrDir($fileName)) {
-				throw new \Sabre\DAV\Exception\Forbidden();
+				$this->fileView->verifyPath($folderPath, $fileName);
+				
+				//get absolute path of the file
+				$absoluteFilePath = $this->fileView->getAbsolutePath($folderPath) . '/' . $fileName;
+				$info = new FileInfo($absoluteFilePath, null, null, array(), null);
+				$node = new BundledFile($this->fileView, $info, $this->contentHandler);
+				$node->acquireLock(ILockingProvider::LOCK_SHARED);
+				$properties = $node->putFile($fileMetadata);
+				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatus($filePath, $properties);
+			} catch (\Exception $exc) {
+				$exc = new BadRequest($exc->getMessage());
+				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatusError($filePath, $exc);
+				continue;
 			}
 
-			$this->fileView->verifyPath($folderPath, $fileName);
+			//release lock as in dav/lib/Connector/Sabre/LockPlugin.php
+			$node->releaseLock(ILockingProvider::LOCK_SHARED);
+			$this->server->tree->markDirty($filePath);
+		}
 
-			//get absolute path of the file
-			$absoluteFilePath = $this->fileView->getAbsolutePath($folderPath) . '/' . $fileName;
-			$info = new FileInfo($absoluteFilePath, null, null, array(), null);
-			$node = new BundledFile($this->fileView, $info);
-			$node->acquireLock(ILockingProvider::LOCK_SHARED);
-			$properties = $node->putFile($requestData);
-		} catch (\Exception $exc) {
-			return $this->handleFileMultiStatusError($filePath, $exc);
+		foreach($multipleRequestsData as $requestData) {
+			$response = $requestData['response'];
+			if (is_null($response)){
+				$exc = new BadRequest('File parsing error');
+				$response = $this->handleFileMultiStatusError($requestData['oc-path'], $exc);
+			}
+			$bundleResponseProperties[] = $response;
 		}
 
-		//release lock as in dav/lib/Connector/Sabre/LockPlugin.php
-		$node->releaseLock(ILockingProvider::LOCK_SHARED);
-		$this->server->tree->markDirty($filePath);
-		return $this->handleFileMultiStatus($filePath, $properties);
+		//multistatus response anounced
+		$this->response->setHeader('Content-Type', 'application/xml; charset=utf-8');
+		$this->response->setStatus(207);
+		$body = $this->server->generateMultiStatus($bundleResponseProperties);
+		$this->response->setBody($body);
+
+		return false;
 	}
-	
+
 	/**
 	 * Adds to multistatus response exception class string and exception message for specific file
 	 *
diff --git a/apps/dav/lib/Files/MultipartContentsParser.php b/apps/dav/lib/Files/MultipartContentsParser.php
index b0994d8c0dd0..e3a3cfd03970 100644
--- a/apps/dav/lib/Files/MultipartContentsParser.php
+++ b/apps/dav/lib/Files/MultipartContentsParser.php
@@ -113,6 +113,7 @@ public function multipartContentSeekToContentLength($contentLength) {
      */
     public function getContent() {
         if ($this->content === null) {
+            // pass body by reference, so other objects can have global access
             $this->content = $this->request->getBody();
 
             if (!$this->content) {
@@ -122,7 +123,7 @@ public function getContent() {
 
         return $this->content;
     }
-
+    
     /**
      * Get a part of request separated by boundrary $boundary.
      *
@@ -132,7 +133,7 @@ public function getContent() {
      * @param  String $boundary
      *
      * @throws \Exception
-     * @return array (array $headers, resource $bodyStream)
+     * @return array $headers
      */
     public function getPartHeaders($boundary) {
         $delimiter = '--'.$boundary."\r\n";
@@ -216,6 +217,10 @@ public function streamReadToString($length) {
             $count -= $bufSize;
         }
 
+        $bytesWritten = strlen($buf);
+        if ($length != $bytesWritten){
+            throw new BadRequest('Method streamRead read '.$bytesWritten.' expeceted '.$length);
+        }
         return $buf;
     }
 
@@ -244,7 +249,7 @@ public function streamReadToStream($target, $length) {
             // note: strlen is expensive so only use it when necessary,
             // on the last block
             if ($bytesWritten === false
-                || ($bytesWritten < $bufSize && $bytesWritten < strlen($buf))
+                || ($bytesWritten < $bufSize)
             ) {
                 // write error, could be disk full ?
                 $returnStatus = false;
@@ -262,7 +267,7 @@ public function streamReadToStream($target, $length) {
      *
      * @param string $content
      * 
-     * @return Array $headers
+     * @return Array $headers or null in case of error
      */
     public function readHeaders($content) {
         $headers = null;
@@ -275,8 +280,8 @@ public function readHeaders($content) {
         foreach (explode("\r\n", $headersContent) as $header) {
             $parts = explode(':', $header, 2);
             if (count($parts) != 2) {
-                //has incorrect header, try to continue
-                continue;
+                //has incorrect header, abort
+                return null;
             }
             $headers[strtolower(trim($parts[0]))] = trim($parts[1]);
         }
diff --git a/apps/dav/tests/temporary/bundling_profile.sh b/apps/dav/tests/temporary/bundling_profile.sh
new file mode 100755
index 000000000000..a86e5ba5be49
--- /dev/null
+++ b/apps/dav/tests/temporary/bundling_profile.sh
@@ -0,0 +1,149 @@
+#!/bin/bash
+
+script_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+
+user='admin'
+pass='admin'
+server='localhost/owncloud'
+upload="/tmp/upload.txt"
+
+
+testfile2="$script_path/zombie.jpg"
+size2=$(du -sb $testfile2 | awk '{ print $1 }')
+md52=$(md5sum $testfile2 | awk '{ print $1 }')
+
+header="<?xml version='1.0' encoding='UTF-8'?>\n
+<d:multipart xmlns:d=\"DAV:\">\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie1.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>0</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie2.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>1</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie3.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>2</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie4.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>3</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie5.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>4</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie6.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>5</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie7.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>6</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie8.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>7</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie9.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>8</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie10.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>9</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+</d:multipart>"
+headersize=$(echo -en $header | wc -c)
+
+mdupload=$(md5sum $upload | awk '{ print $1 }')
+boundrary="boundary_$mdupload"
+
+#CONTENTS
+echo -en "--$boundrary\r\nContent-Type: text/xml; charset=utf-8\r\nContent-Length: $headersize\r\n\r\n" > $upload
+echo -en $header >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 0\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 1\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 2\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 3\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 4\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 5\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 6\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 7\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 8\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+echo -en "\r\n--$boundrary\r\nContent-ID: 9\r\n\r\n" >> $upload
+cat $testfile2 >> $upload
+
+#END BOUNDRARY
+echo -en "\r\n--$boundrary--\r\n" >> $upload
+
+#POST
+#curl -X DELETE -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" "http://$server/remote.php/webdav/config.cfg"
+
+blackfire --samples 1 curl -X POST -H "Content-Type: multipart/related; boundary=$boundrary" --cookie "XDEBUG_SESSION=MROW4A;path=/;" \
+    --data-binary "@$upload" \
+    "http://$user:$pass@$server/remote.php/dav/files/$user"
+
+
+
+
diff --git a/apps/dav/tests/temporary/bundling_tests.sh b/apps/dav/tests/temporary/bundling_tests.sh
index 5e581336c3dd..617469d580dc 100755
--- a/apps/dav/tests/temporary/bundling_tests.sh
+++ b/apps/dav/tests/temporary/bundling_tests.sh
@@ -4,33 +4,52 @@ script_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
 
 user='admin'
 pass='admin'
-server='localhost:8080'
+server='localhost:8080/owncloud'
 upload="/tmp/upload.txt"
 
-testfile0="/tmp/test.txt"
-echo -en "abcd" > $testfile0
-size0=$(du -sb $testfile0 | awk '{ print $1 }')
-md50=$(md5sum $testfile0 | awk '{ print $1 }')
 
-testfile1="$script_path/bundling_tests.sh"
+testfile1="$script_path/put_test.sh"
 size1=$(du -sb $testfile1 | awk '{ print $1 }')
 md51=$(md5sum $testfile1 | awk '{ print $1 }')
+id1="0"
 
 testfile2="$script_path/zombie.jpg"
 size2=$(du -sb $testfile2 | awk '{ print $1 }')
 md52=$(md5sum $testfile2 | awk '{ print $1 }')
+id2="1"
+
+header="<?xml version='1.0' encoding='UTF-8'?>\n
+<d:multipart xmlns:d=\"DAV:\">\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/put_test.sh</d:oc-path>\n
+            <d:oc-mtime>1476393777</d:oc-mtime>\n
+            <d:oc-id>$id1</d:oc-id>\n
+            <d:oc-total-length>$size1</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+    <d:part>\n
+        <d:prop>\n
+            <d:oc-path>/test/zombie.jpg</d:oc-path>\n
+            <d:oc-mtime>1476393386</d:oc-mtime>\n
+            <d:oc-id>$id2</d:oc-id>\n
+            <d:oc-total-length>$size2</d:oc-total-length>\n
+        </d:prop>\n
+    </d:part>\n
+</d:multipart>"
+headersize=$(echo -en $header | wc -c)
 
 mdupload=$(md5sum $upload | awk '{ print $1 }')
 boundrary="boundary_$mdupload"
 
 #CONTENTS
-echo -en "--$boundrary\r\nX-OC-Method: PUT\r\nX-OC-Path: test/test.txt\r\nX-OC-Mtime: 1471254375\r\nContent-length: $size0\r\nContent-MD5: $md50\r\n\r\n" > $upload
-cat $testfile0 >> $upload
+echo -en "--$boundrary\r\nContent-Type: text/xml; charset=utf-8\r\nContent-Length: $headersize\r\n\r\n" > $upload
+echo -en $header >> $upload
 
-echo -en "\r\n--$boundrary\r\nX-OC-Method: PUT\r\nX-OC-Path: bundling_tests.sh\r\nX-OC-Mtime: 1471254475\r\nContent-length: $size1\r\nContent-MD5: $md51\r\n\r\n" >> $upload
+echo -en "\r\n--$boundrary\r\nContent-ID: $id1\r\n\r\n" >> $upload
 cat $testfile1 >> $upload
 
-echo -en "\r\n--$boundrary\r\nX-OC-Method: PUT\r\nX-OC-Path: test/zombie1.jpg\r\nX-OC-Mtime: 1471254275\r\nContent-length: $size2\r\nContent-MD5: $md52\r\n\r\n" >> $upload
+echo -en "\r\n--$boundrary\r\nContent-ID: $id2\r\n\r\n" >> $upload
 cat $testfile2 >> $upload
 
 #END BOUNDRARY
@@ -39,7 +58,7 @@ echo -en "\r\n--$boundrary--\r\n" >> $upload
 #POST
 #curl -X DELETE -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" "http://$server/remote.php/webdav/config.cfg"
 
-curl -X POST -H "Content-Type: multipart/mixed; boundary=$boundrary" --cookie "XDEBUG_SESSION=MROW4A;path=/;" \
+curl -X POST -H "Content-Type: multipart/related; boundary=$boundrary" --cookie "XDEBUG_SESSION=MROW4A;path=/;" \
     --data-binary "@$upload" \
     "http://$user:$pass@$server/remote.php/dav/files/$user"
 
diff --git a/apps/dav/tests/temporary/put_test.sh b/apps/dav/tests/temporary/put_test.sh
index ca111f3083a9..c3b64dee4483 100755
--- a/apps/dav/tests/temporary/put_test.sh
+++ b/apps/dav/tests/temporary/put_test.sh
@@ -4,9 +4,9 @@ script_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
 
 user='admin'
 pass='admin'
-server='localhost:8080'
+server='localhost/owncloud'
 
 testfile2="$script_path/zombie.jpg"
 
-#blackfire --samples 1 curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"
-curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"
+blackfire --samples 1 curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"
+#curl -X PUT -u $user:$pass --cookie "XDEBUG_SESSION=MROW4A;path=/;" --data-binary @"$testfile2" "http://$server/remote.php/webdav/test/zombie.jpg"
diff --git a/apps/dav/tests/unit/Files/BundledFileTest.php b/apps/dav/tests/unit/Files/BundledFileTest.php
index 4e201492e566..67e9aca8c11b 100644
--- a/apps/dav/tests/unit/Files/BundledFileTest.php
+++ b/apps/dav/tests/unit/Files/BundledFileTest.php
@@ -41,6 +41,8 @@ class BundledFileTest extends \Test\TestCase {
 	 */
 	private $user;
 
+	/* BASICS */
+
 	public function setUp() {
 		parent::setUp();
 
@@ -61,6 +63,57 @@ public function tearDown() {
 		parent::tearDown();
 	}
 
+	/* TESTS */
+
+	/**
+	 * Test basic successful bundled file PutFile
+	 */
+	public function testPutFile() {
+		$bodyContent = 'blabla';
+		$headers['oc-total-length'] = 6;
+		$headers['oc-path'] = '/foo.txt';
+		$headers['oc-mtime'] = '1473336321';
+		$headers['response'] = null;
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "$bodyContent\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+
+		$this->doPutFIle($headers, $multipartContentsParser);
+	}
+
+	/**
+	 * Test basic successful bundled file PutFile
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage File requires oc-total-length header to be read
+	 */
+	public function testPutFileNoLength() {
+		$bodyContent = 'blabla';
+		$headers['oc-path'] = '/foo.txt';
+		$headers['oc-mtime'] = '1473336321';
+		$headers['response'] = null;
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "$bodyContent\r\n--boundary--";
+		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
+
+		$this->doPutFIle($headers, $multipartContentsParser);
+	}
+
+	/**
+	 * Test putting a single file
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage PUT method not supported for bundling
+	 */
+	public function testThrowIfPut() {
+		$fileContents = $this->getStream('test data');
+		$this->doPut('/foo.txt', $fileContents);
+	}
+
+	/* UTILITIES */
+
 	private function getMockStorage() {
 		$storage = $this->getMockBuilder('\OCP\Files\Storage')
 			->getMock();
@@ -80,44 +133,53 @@ private function getStream($string) {
 		return $stream;
 	}
 
-//	/**
-//	 * Simulate putting a file to the given path.
-//	 *
-//	 * @param string $path path to put the file into
-//	 * @param string $viewRoot root to use for the view
-//	 *
-//	 * @return null|string of the PUT operaiton which is usually the etag
-//	 */
-//	private function doCreate($path, $fileContents, $viewRoot = null) {
-//		$view = \OC\Files\Filesystem::getView();
-//		if (!is_null($viewRoot)) {
-//			$view = new \OC\Files\View($viewRoot);
-//		} else {
-//			$viewRoot = '/' . $this->user . '/files';
-//		}
-//
-//		$info = new \OC\Files\FileInfo(
-//			$viewRoot . '/' . ltrim($path, '/'),
-//			$this->getMockStorage(),
-//			null,
-//			['permissions' => \OCP\Constants::PERMISSION_ALL],
-//			null
-//		);
-//
-//		$file = new BundledFile($view, $info);
-//
-//		// beforeMethod locks
-//		$view->lockFile($path, ILockingProvider::LOCK_SHARED);
-//
-//		$fileAttributes['content-id'] = 0;
-//		$fileAttributes['x-oc-mtime'] = "1471254375";
-//		$result = $file->createFile($fileContents, $fileAttributes);
-//
-//		// afterMethod unlocks
-//		$view->unlockFile($path, ILockingProvider::LOCK_SHARED);
-//
-//		return $result;
-//	}
+	/**
+	 * TODO:
+	 */
+	private function doPutFIle($fileMetadata, $contentHandler, $viewRoot = null) {
+		$path = $fileMetadata['oc-path'];
+		$view = \OC\Files\Filesystem::getView();
+		if (!is_null($viewRoot)) {
+			$view = new \OC\Files\View($viewRoot);
+		} else {
+			$viewRoot = '/' . $this->user . '/files';
+		}
+
+		$info = new \OC\Files\FileInfo(
+			$viewRoot . '/' . ltrim($path, '/'),
+			$this->getMockStorage(),
+			null,
+			['permissions' => \OCP\Constants::PERMISSION_ALL],
+			null
+		);
+
+		$file = new BundledFile($view, $info, $contentHandler);
+
+		// beforeMethod locks
+		$view->lockFile($path, ILockingProvider::LOCK_SHARED);
+
+		$result = $file->putFile($fileMetadata);
+
+		// afterMethod unlocks
+		$view->unlockFile($path, ILockingProvider::LOCK_SHARED);
+
+		return $result;
+	}
+
+	private function fillMultipartContentsParserStreamWithBody($bodyString){
+		$bodyStream = fopen('php://temp', 'r+');
+		fwrite($bodyStream, $bodyString);
+		rewind($bodyStream);
+		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
+			->disableOriginalConstructor()
+			->getMock();
+		$request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+
+		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
+		return $mcp;
+	}
 
 	/**
 	 * Simulate putting a file to the given path.
@@ -143,7 +205,7 @@ private function doPut($path, $fileContents, $viewRoot = null) {
 			null
 		);
 
-		$file = new BundledFile($view, $info);
+		$file = new BundledFile($view, $info, null);
 
 		// beforeMethod locks
 		$view->lockFile($path, ILockingProvider::LOCK_SHARED);
@@ -155,15 +217,4 @@ private function doPut($path, $fileContents, $viewRoot = null) {
 
 		return $result;
 	}
-
-	/**
-	 * Test putting a single file
-	 * 
-	 * @expectedException \Sabre\DAV\Exception\Forbidden
-	 * @expectedExceptionMessage PUT method not supported for bundling
-	 */
-	public function testThrowPutSingleFile() {
-		$fileContents = $this->getStream('test data');
-		$this->doPut('/foo.txt', $fileContents);
-	}
 }
diff --git a/apps/dav/tests/unit/Files/MultipartContentsParserTest.php b/apps/dav/tests/unit/Files/MultipartContentsParserTest.php
index f97765c5bfb8..4515cd2e1bc3 100644
--- a/apps/dav/tests/unit/Files/MultipartContentsParserTest.php
+++ b/apps/dav/tests/unit/Files/MultipartContentsParserTest.php
@@ -33,7 +33,11 @@ protected function setUp() {
 
 	}
 
+	/*TESTS*/
+
 	/**
+	 * Test basic gets() functionality, that if passed string instead of resource, it should fail
+	 *
 	 * @expectedException \Sabre\DAV\Exception\BadRequest
 	 * @expectedExceptionMessage Unable to get request content
 	 */
@@ -53,8 +57,8 @@ public function testGetsThrowWrongContents() {
 	}
 
 	/**
-	 * @expectedException \Sabre\DAV\Exception\BadRequest
-	 * @expectedExceptionMessage Unable to determine headers limit for content part
+	 * Test function readHeaders(), so if passed empty string, it will return null
+	 *
 	 */
 	public function testReadHeadersThrowEmptyHeader() {
 		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
@@ -63,19 +67,7 @@ public function testReadHeadersThrowEmptyHeader() {
 
 		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
 		$mcp->readHeaders('');
-	}
-
-	/**
-	 * @expectedException \Sabre\DAV\Exception\BadRequest
-	 * @expectedExceptionMessage Header of content part contains incorrect headers
-	 */
-	public function testReadHeadersThrowIncorrectHeader() {
-		$request = $this->getMockBuilder('Sabre\HTTP\RequestInterface')
-			->disableOriginalConstructor()
-			->getMock();
-
-		$mcp = new \OCA\DAV\Files\MultipartContentsParser($request);
-		$mcp->readHeaders("Content-ID: 1\r\nContent-MD5\r\n\r\n");
+		$this->assertEquals(null, $mcp->readHeaders(''));
 	}
 
 	/**
@@ -146,7 +138,7 @@ private function streamReadToStreamBuilder($length) {
 	}
 
 	/**
-	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedException \Exception
 	 * @expectedExceptionMessage An error appears while reading and parsing header of content part using fgets
 	 */
 	public function testGetPartThrowFailfgets() {
@@ -173,7 +165,7 @@ public function testGetPartThrowFailfgets() {
 	/**
 	 * If one one the content parts does not contain boundrary, means that received wrong request
 	 *
-	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedException \Exception
 	 * @expectedExceptionMessage Expected boundary delimiter in content part
 	 */
 	public function testGetPartThrowNoBoundraryFound() {
@@ -225,15 +217,17 @@ public function testMultipartContentSeekToContentLength() {
 		$this->assertEquals(true,$mcp->multipartContentSeekToContentLength($length));
 	}
 
-	public function testGetPartWrongBoundaryCases() {
+	/**
+	 *  Test cases with wrong or incomplete boundraries
+	 *
+	 */
+	public function testGetPartHeadersWrongBoundaryCases() {
 		// Calling multipletimes getPart on parts without contents should return null and signal immedietaly that endDelimiter was reached
 		$bodyFull = "--boundary\r\n--boundary_wrong\r\n--boundary--";
 		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
 		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
 		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
-	}
 
-	public function testGetPartContents() {
 		// Test empty content
 		$bodyFull = "--boundary\r\n";
 		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
@@ -257,92 +251,134 @@ public function testGetPartContents() {
 		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
 		$this->assertEquals(null,$multipartContentsParser->getPartHeaders($this->boundrary));
 		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+	}
 
+	/**
+	 *  Test will check if we can correctly parse headers and content using streamReadToString
+	 *
+	 */
+	public function testReadHeaderBodyCorrect() {
+		//multipart part will have some content bodyContent and some headers
 		$bodyContent = 'blabla';
+		$headers['content-length'] = '6';
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
 		$bodyFull = '--boundary'
-			."\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
-			."$bodyContent\r\n--boundary";
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\nContent-length: ".$headers['content-length']
+			."\r\n\r\n"
+			."$bodyContent\r\n--boundary--";
 		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
-		$headers['content-length'] = '6';
-		$headers['content-type'] = 'application/json; charset=UTF-8';
-		$headers['content-id'] = '0';
+
+		//parse it
 		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
 		$bodyParsed = $multipartContentsParser->streamReadToString(6);
+
+		//check if end delimiter is not reached, since we just read 6 bytes, and stopped at \r\n
 		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
+
+		//check that we parsed correct headers
 		$this->assertEquals($bodyContent, $bodyParsed);
 		$this->assertEquals($headers, $headersParsed);
+
+		//parse further to check if there is new part. There is no, so headers are null and delimiter reached
 		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
 		$this->assertEquals(null,$headersParsed);
 		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+	}
+
+	/**
+	 *  Test will check parsing incorrect headers and content using streamReadToString
+	 *
+	 */
+	public function testReadHeaderBodyIncorrect() {
 
-		// Test First part with content and second without content returning null
-		// The behaviour is motivated by the fact that if there is noting between start content boundrary and the end of multipart boundrary,
-		// it should not raise and error, but simply skip contents returning null and setting endDelimiterReached to true.
+		//multipart part will have some content bodyContent and some headers
 		$bodyContent = 'blabla';
+		$headers['content-length'] = '6';
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will one correct and one incorrect header
 		$bodyFull = '--boundary'
-			."\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
-			."$bodyContent\r\n--boundary\r\n--boundary--";
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\nContent-length"
+			."\r\n\r\n"
+			."$bodyContent\r\n--boundary--";
 		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
-		$headers['content-length'] = '6';
-		$headers['content-type'] = 'application/json; charset=UTF-8';
-		$headers['content-id'] = '0';
+
+		//parse it and expect null, since contains incorrect headers
 		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
-		$bodyParsed = $multipartContentsParser->streamReadToString(6);
+		$this->assertEquals(null, $headersParsed);
 		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
-		$this->assertEquals($bodyContent, $bodyParsed);
-		$this->assertEquals($headers, $headersParsed);
+
+		//parse further to check if next call with not read headers again
+		//this should return null again and get to end of delimiter
 		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
 		$this->assertEquals(null,$headersParsed);
 		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+	}
 
-		// Test First part without content and second with content, expects that it will just skip the empty boundrary and read the next contents within the same run of getPart
-		// The behaviour is motivated by the fact that iterator at the first boundrary occurence expects next line to be contents and it will iterate till it finds it.
-		// It should set endDelimiterReached to true after next call for header
+	/**
+	 *  Test will check reading error in StreamReadToString
+	 *
+	 * @expectedException \Sabre\DAV\Exception\BadRequest
+	 * @expectedExceptionMessage Method streamRead read 20 expeceted 60
+	 */
+	public function testReadBodyIncorrect() {
+		//multipart part will have some content bodyContent and content-length header will specify to big value
+		//this
 		$bodyContent = 'blabla';
+		$headers['content-length'] = '60';
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
 		$bodyFull = '--boundary'
-			."\r\n--boundary\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\nContent-length: ".$headers['content-length']
+			."\r\n\r\n"
 			."$bodyContent\r\n--boundary--";
 		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
-		$headers['content-length'] = '6';
-		$headers['content-type'] = 'application/json; charset=UTF-8';
-		$headers['content-id'] = '0';
+
+		//parse headers
 		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
-		$bodyParsed = $multipartContentsParser->streamReadToString(6);
-		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
-		$this->assertEquals($bodyContent, $bodyParsed);
 		$this->assertEquals($headers, $headersParsed);
-		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
-		$this->assertEquals(null,$headersParsed);
-		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
 
-		// Test First part without content and second with content, expects that it will return first empty string and next will be content
+		$this->assertEquals(true, array_key_exists('content-length',$headersParsed));
+		$multipartContentsParser->streamReadToString($headersParsed['content-length']);
+	}
+
+	/**
+	 *  Test will check reading error in StreamReadToString return false
+	 *
+	 */
+	public function testReadBodyStreamIncorrect() {
+		//multipart part will have some content bodyContent and content-length header will specify to big value
+		//this
 		$bodyContent = 'blabla';
+		$headers['content-length'] = '60';
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
 		$bodyFull = '--boundary'
-			."\r\nContent-ID: 0\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 0\r\n\r\n"
-			."\r\n--boundary\r\nContent-ID: 1\r\nContent-Type: application/json; charset=UTF-8\r\nContent-length: 6\r\n\r\n"
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\nContent-length: ".$headers['content-length']
+			."\r\n\r\n"
 			."$bodyContent\r\n--boundary--";
 		$multipartContentsParser = $this->fillMultipartContentsParserStreamWithBody($bodyFull);
-		$headers['content-length'] = '0';
-		$headers['content-type'] = 'application/json; charset=UTF-8';
-		$headers['content-id'] = '0';
-		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
-		$bodyParsed = $multipartContentsParser->streamReadToString(0);
-		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
-		$this->assertEquals("", $bodyParsed);
-		$this->assertEquals($headers, $headersParsed);
-		$headers['content-length'] = '6';
-		$headers['content-type'] = 'application/json; charset=UTF-8';
-		$headers['content-id'] = '1';
+
+		//parse headers
 		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
-		$bodyParsed = $multipartContentsParser->streamReadToString(6);
-		$this->assertEquals(false,$multipartContentsParser->getEndDelimiterReached());
-		$this->assertEquals($bodyContent, $bodyParsed);
 		$this->assertEquals($headers, $headersParsed);
-		$headersParsed = $multipartContentsParser->getPartHeaders($this->boundrary);
-		$this->assertEquals(null,$headersParsed);
-		$this->assertEquals(true,$multipartContentsParser->getEndDelimiterReached());
+
+		$this->assertEquals(true, array_key_exists('content-length',$headersParsed));
+		$target = fopen('php://temp', 'r+');
+		$bodyParsed = $multipartContentsParser->streamReadToStream($target, $headersParsed['content-length']);
+		$this->assertEquals(false, $bodyParsed);
 	}
 
+	/*UTILITIES*/
+
 	private function fillMultipartContentsParserStreamWithChars($length){
 		$bodyStream = fopen('php://temp', 'r+');
 		$bodyString = '';

From 4d16d331d82b4e8d9225246c906fb16f4aa116d9 Mon Sep 17 00:00:00 2001
From: Piotr M <mrow4a@yahoo.com>
Date: Fri, 25 Nov 2016 14:17:43 +0100
Subject: [PATCH 4/4] cover feature with unit tests

---
 apps/dav/lib/Files/BundledFile.php            |  21 +-
 apps/dav/lib/Files/BundlingPlugin.php         |  98 +--
 .../dav/tests/unit/Files/BundlePluginTest.php | 709 ++++++++++++++++++
 apps/dav/tests/unit/Files/BundledFileTest.php |  29 +-
 4 files changed, 768 insertions(+), 89 deletions(-)
 create mode 100644 apps/dav/tests/unit/Files/BundlePluginTest.php

diff --git a/apps/dav/lib/Files/BundledFile.php b/apps/dav/lib/Files/BundledFile.php
index 8ecb92616b26..e9aae4e3b8cb 100644
--- a/apps/dav/lib/Files/BundledFile.php
+++ b/apps/dav/lib/Files/BundledFile.php
@@ -81,19 +81,22 @@ public function __construct($view, $info, $contentHandler){
 	 */
 	public function putFile($data) {
 		$properties = array();
+
+		if (!isset($data['oc-total-length'])) {
+			//this should not happen, since upper layer takes care of that
+			//Thus, return Forbidden as sign of code inconsistency
+			throw new Forbidden('File requires oc-total-length header to be read');
+		}
+
 		try {
 			$exists = $this->fileView->file_exists($this->path);
 			if ($this->info && $exists) {
+				$this->contentHandler->multipartContentSeekToContentLength($data['oc-total-length']);
 				throw new Forbidden('Bundling not supported for already existing files');
 			}
 		} catch (StorageNotAvailableException $e) {
-			throw new ServiceUnavailable("File is not updatable: " . $e->getMessage());
-		}
-
-		if (!isset($data['oc-total-length'])) {
-			//this should not happen, since upper layer takes care of that
-			//Thus, return Forbidden as sign of code inconsistency
-			throw new Forbidden('File requires oc-total-length header to be read');
+			$this->contentHandler->multipartContentSeekToContentLength($data['oc-total-length']);
+			throw new ServiceUnavailable("StorageNotAvailableException raised");
 		}
 
 		// verify path of the target
@@ -108,9 +111,10 @@ public function putFile($data) {
 		list($storage, $internalPath) = $this->fileView->resolvePath($this->path);
 		try {
 			$target = $partStorage->fopen($internalPartPath, 'wb');
-			if ($target === false) {
+			if ($target === false || $target === null) {
 				\OCP\Util::writeLog('webdav', '\OC\Files\Filesystem::fopen() failed', \OCP\Util::ERROR);
 				// because we have no clue about the cause we can only throw back a 500/Internal Server Error
+				$this->contentHandler->multipartContentSeekToContentLength($data['oc-total-length']);
 				throw new Exception('Could not write file contents');
 			}
 
@@ -170,7 +174,6 @@ public function putFile($data) {
 			}
 
 			// allow sync clients to send the mtime along in a header
-			$request = \OC::$server->getRequest();
 			if (isset($data['oc-mtime'])) {
 				if ($this->fileView->touch($this->path, $data['oc-mtime'])) {
 					$properties['{DAV:}oc-mtime'] = 'accepted';
diff --git a/apps/dav/lib/Files/BundlingPlugin.php b/apps/dav/lib/Files/BundlingPlugin.php
index 9cd655765500..91b4d0e559ef 100644
--- a/apps/dav/lib/Files/BundlingPlugin.php
+++ b/apps/dav/lib/Files/BundlingPlugin.php
@@ -31,10 +31,6 @@
 use Sabre\DAV\Exception\BadRequest;
 use Sabre\DAV\Exception;
 use OCA\DAV\Connector\Sabre\Exception\Forbidden;
-use OCA\DAV\Connector\Sabre\Exception\InvalidPath;
-use OCA\DAV\Connector\Sabre\Exception\FileLocked;
-use OCP\Files\ForbiddenException;
-use OCP\Lock\LockedException;
 
 /**
  * This plugin is responsible for interconnecting three components of the OC server:
@@ -138,7 +134,7 @@ public function handleBundle(RequestInterface $request, ResponseInterface $respo
 		//Update the content handler of the bundle body
 		$this->contentHandler = $this->getContentHandler($this->request);
 
-		$multipleRequestsData = $this->parseBundleHeader();
+		$multipleRequestsData = $this->parseBundleMetadata();
 
 		//Process bundle and send a multistatus response
 		$result = $this->processBundle($multipleRequestsData);
@@ -149,7 +145,6 @@ public function handleBundle(RequestInterface $request, ResponseInterface $respo
 	/**
 	 * Check multipart headers.
 	 *
-	 * @throws /Sabre\DAV\Exception\BadRequest
 	 * @throws /Sabre\DAV\Exception\Forbidden
 	 * @return void
 	 */
@@ -166,9 +161,9 @@ private function validateRequest() {
 		foreach ($headers as $header) {
 			$value = $this->request->getHeader($header);
 			if ($value === null) {
-				throw new BadRequest(sprintf('%s header is needed', $header));
+				throw new Forbidden(sprintf('%s header is needed', $header));
 			} elseif (!is_int($value) && empty($value)) {
-				throw new BadRequest(sprintf('%s header must not be empty', $header));
+				throw new Forbidden(sprintf('%s header must not be empty', $header));
 			}
 		}
 
@@ -180,7 +175,7 @@ private function validateRequest() {
 		$contentType = trim($contentParts[0]);
 		$expectedContentType = 'multipart/related';
 		if ($contentType != $expectedContentType) {
-			throw new BadRequest(sprintf(
+			throw new Forbidden(sprintf(
 				'Content-Type must be %s',
 				$expectedContentType
 			));
@@ -190,7 +185,7 @@ private function validateRequest() {
 		$boundaryPart = trim($contentParts[1]);
 		$shouldStart = 'boundary=';
 		if (substr($boundaryPart, 0, strlen($shouldStart)) != $shouldStart) {
-			throw new BadRequest('Boundary is not set');
+			throw new Forbidden('Boundary is not set');
 		}
 		$boundary = substr($boundaryPart, strlen($shouldStart));
 		if (substr($boundary, 0, 1) == '"' && substr($boundary, -1) == '"') {
@@ -202,19 +197,13 @@ private function validateRequest() {
 	/**
 	 * Parses multipart contents and send appropriete response
 	 *
-	 * @throws \Sabre\DAV\Exception\BadRequest
+	 * @throws \Sabre\DAV\Exception\Forbidden
 	 *
 	 * @return array $multipleRequestsData
 	 */
-	private function parseBundleHeader() {
+	private function parseBundleMetadata() {
 		$multipleRequestsData = array();
 		try {
-			//get multipart header for one of the contents
-			if ($this->contentHandler->getEndDelimiterReached()){
-				//endDelimiter reached, break
-				return $multipleRequestsData;
-			}
-
 			// Verify metadata part headers
 			$bundleMetadata = null;
 			try{
@@ -243,22 +232,31 @@ private function parseBundleHeader() {
 			$bundleMetadataBody = $this->contentHandler->streamReadToString($bundleMetadata['content-length']);
 
 			$bundleMetadataBody = preg_replace("/xmlns(:[A-Za-z0-9_])?=(\"|\')DAV:(\"|\')/","xmlns\\1=\"urn:DAV\"",$bundleMetadataBody);
+
+			//Try to load xml
 			$xml = simplexml_load_string($bundleMetadataBody);
-			unset($bundleMetadataBody);
+			if (false === $xml) {
+				$mlerror = libxml_get_errors();
+				throw new \Exception('Bundle metadata contains incorrect xml structure. Unable to parse whole bundle request');
+			}
 			$xml->registerXPathNamespace('d','urn:DAV');
+			unset($bundleMetadataBody);
 
 			if(1 != count($xml->xpath('/d:multipart'))){
-				throw new \Exception('Bundle metadata does not contain d:multipart children element. Unable to parse whole bundle request');
+				throw new \Exception('Bundle metadata does not contain d:multipart children elements');
 			}
 
-			foreach ($xml->xpath('/d:multipart/d:part/d:prop') as $prop) {
+			$fileMetadataObjectXML = $xml->xpath('/d:multipart/d:part/d:prop');
+
+			if(0 == count($fileMetadataObjectXML)){
+				throw new \Exception('Bundle metadata does not contain d:multipart/d:part/d:prop children elements');
+			}
+
+			foreach ($fileMetadataObjectXML as $prop) {
 				$fileMetadata = get_object_vars($prop->children('d', TRUE));
-				$headers = array('oc-path', 'oc-mtime', 'oc-id', 'oc-total-length');
-				foreach ($headers as $header) {
-					if (in_array($header,$fileMetadata) && (count($fileMetadata->{$header} == 1))) {
-						throw new \Exception($header.' header is needed in the bundle metadata for each file. Unable to parse whole bundle request');
-					}
-				}
+
+				// if any of the field is not contained,
+				// bthe try-catch clausule will raise Undefined index exception
 				$contentID = intval($fileMetadata['oc-id']);
 				if(array_key_exists($contentID, $multipleRequestsData)){
 					throw new \Exception('One or more files have the same Content-ID '.$contentID.'. Unable to parse whole bundle request');
@@ -269,7 +267,8 @@ private function parseBundleHeader() {
 				$multipleRequestsData[$contentID]['response'] = null;
 			}
 		} catch (\Exception $e) {
-			throw new BadRequest($e->getMessage());
+			libxml_clear_errors();
+			throw new Forbidden($e->getMessage());
 		}
 		return $multipleRequestsData;
 	}
@@ -303,43 +302,10 @@ private function processBundle($multipleRequestsData) {
 			$fileMetadata = $multipleRequestsData[$fileID];
 
 			$filePath = $fileMetadata['oc-path'];
-
-			if ($this->server->tree->nodeExists($filePath)) {
-				//set error response for that object
-				$exc = new BadRequest('Method not allowed - file exists - update of the file is not supported!');
-				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatusError($filePath, $exc);
-				continue;
-			}
-
+			
 			list($folderPath, $fileName) = URLUtil::splitPath($filePath);
 
-			if ($folderPath === ''){
-				$fullFolderPath = $this->userFilesHome;
-			}
-			else{
-				$fullFolderPath = $this->userFilesHome . '/' . $folderPath;
-			}
-
-			// For non-chunked upload it is enough to check if we can create a new file in a parent folder
-			if (!isset($this->cacheValidParents[$folderPath])){
-				$this->cacheValidParents[$folderPath] = ($this->server->tree->nodeExists($fullFolderPath) && $this->fileView->isCreatable($folderPath));
-			}
-
-			if (!$this->cacheValidParents[$folderPath]) {
-				$exc = new BadRequest('File creation on not existing or without creation permission parent folder is not permitted');
-				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatusError($filePath, $exc);
-				continue;
-			}
-
 			try {
-				# the check here is necessary, because createFile uses put covered in sabre/file.php
-				# and not touch covered in files/view.php
-				if (\OC\Files\Filesystem::isForbiddenFileOrDir($fileName)) {
-					throw new \Sabre\DAV\Exception\Forbidden();
-				}
-
-				$this->fileView->verifyPath($folderPath, $fileName);
-				
 				//get absolute path of the file
 				$absoluteFilePath = $this->fileView->getAbsolutePath($folderPath) . '/' . $fileName;
 				$info = new FileInfo($absoluteFilePath, null, null, array(), null);
@@ -348,11 +314,13 @@ private function processBundle($multipleRequestsData) {
 				$properties = $node->putFile($fileMetadata);
 				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatus($filePath, $properties);
 			} catch (\Exception $exc) {
+				//TODO: This should not be BadRequest! This should be any exception - how to do it carefully?
 				$exc = new BadRequest($exc->getMessage());
 				$multipleRequestsData[$fileID]['response'] = $this->handleFileMultiStatusError($filePath, $exc);
 				continue;
 			}
 
+			//TODO: do we need to unlock file if putFile failed? In this version we dont (does continue)
 			//release lock as in dav/lib/Connector/Sabre/LockPlugin.php
 			$node->releaseLock(ILockingProvider::LOCK_SHARED);
 			$this->server->tree->markDirty($filePath);
@@ -381,7 +349,7 @@ private function processBundle($multipleRequestsData) {
 	 *
 	 * @return array $entry
 	 */
-	protected function handleFileMultiStatusError($ocPath, $exc){
+	private function handleFileMultiStatusError($ocPath, $exc){
 		$status = $exc->getHTTPCode();
 		$entry['href'] = $this->userFilesHome;
 		$entry[$status]['{DAV:}error']['{http://sabredav.org/ns}exception'] = get_class($exc);
@@ -395,7 +363,7 @@ protected function handleFileMultiStatusError($ocPath, $exc){
 	 *
 	 * @return array $entry
 	 */
-	protected function handleFileMultiStatus($ocPath, $properties){
+	private function handleFileMultiStatus($ocPath, $properties){
 		$entry['href'] = $this->userFilesHome;
 		$entry[200] = $properties;
 		$entry[200]['{DAV:}oc-path'] = $ocPath;
@@ -408,7 +376,7 @@ protected function handleFileMultiStatus($ocPath, $properties){
 	 * @param  RequestInterface $request
 	 * @return \OCA\DAV\Files\MultipartContentsParser
 	 */
-	protected function getContentHandler(RequestInterface $request) {
+	private function getContentHandler(RequestInterface $request) {
 		if ($this->contentHandler === null) {
 			return new MultipartContentsParser($request);
 		}
diff --git a/apps/dav/tests/unit/Files/BundlePluginTest.php b/apps/dav/tests/unit/Files/BundlePluginTest.php
new file mode 100644
index 000000000000..72f605881622
--- /dev/null
+++ b/apps/dav/tests/unit/Files/BundlePluginTest.php
@@ -0,0 +1,709 @@
+<?php
+/**
+ * @author Piotr Mrowczynski <Piotr.Mrowczynski@owncloud.com>
+ * @copyright Copyright (c) 2016, ownCloud GmbH.
+ * @license AGPL-3.0
+ *
+ * This code is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License, version 3,
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+namespace OCA\DAV\Files;
+
+use OC\Files\FileInfo;
+use OC\Files\Storage\Local;
+use Sabre\HTTP\RequestInterface;
+use Test\TestCase;
+use OC\Files\View;
+use OCP\Files\Storage;
+use Sabre\DAV\Exception;
+use OC\Files\Filesystem;
+use OCP\Files\StorageNotAvailableException;
+
+/**
+ * Class BundlingPlugin
+ *
+ * @group DB
+ *
+ * @package OCA\DAV\Tests\unit\Files
+ */
+class BundlingPluginTest extends TestCase {
+
+	/**
+	 * @var string
+	 */
+	private $user;
+
+	/** @var \OC\Files\View | \PHPUnit_Framework_MockObject_MockObject */
+	private $view;
+
+	/** @var \OC\Files\FileInfo | \PHPUnit_Framework_MockObject_MockObject */
+	private $info;
+
+	/**
+	 * @var \Sabre\DAV\Server | \PHPUnit_Framework_MockObject_MockObject
+	 */
+	private $server;
+
+	/**
+	 * @var FilesPlugin
+	 */
+	private $plugin;
+
+	/**
+	 * @var \Sabre\HTTP\RequestInterface | \PHPUnit_Framework_MockObject_MockObject
+	 */
+	private $request;
+	/**
+	 * @var \Sabre\HTTP\ResponseInterface | \PHPUnit_Framework_MockObject_MockObject
+	 */
+	private $response;
+
+	/**
+	 * @var MultipartContentsParser | \PHPUnit_Framework_MockObject_MockObject
+	 */
+	private $contentHandler;
+
+	const BOUNDRARY = 'test_boundrary';
+
+	public function setUp() {
+		parent::setUp();
+//		$this->server = new \Sabre\DAV\Server();
+
+		$this->server = $this->getMockBuilder('\Sabre\DAV\Server')
+			->setConstructorArgs(array())
+			->setMethods(array('emit'))
+			->getMock();
+
+		$this->server->tree = $this->getMockBuilder('\Sabre\DAV\Tree')
+			->disableOriginalConstructor()
+			->getMock();
+
+		// setup
+		$storage = $this->getMockBuilder(Local::class)
+			->setMethods(["fopen","moveFromStorage","file_exists"])
+			->setConstructorArgs([['datadir' => \OC::$server->getTempManager()->getTemporaryFolder()]])
+			->getMock();
+		$storage->method('fopen')
+			->will($this->returnCallback(
+				function ($path,$mode) {
+					$bodyStream = fopen('php://temp', 'r+');
+					return $bodyStream;
+				}
+			));
+		$storage->method('moveFromStorage')
+			->will($this->returnValue(true));
+		$storage->method('file_exists')
+			->will($this->returnValue(true));
+
+		\OC_Hook::clear();
+
+		$this->user = $this->getUniqueID('user_');
+		$userManager = \OC::$server->getUserManager();
+		$userManager->createUser($this->user, 'pass');
+
+		$this->loginAsUser($this->user);
+
+		Filesystem::mount($storage, [], $this->user . '/');
+
+		$this->view = $this->getMockBuilder(View::class)
+			->setMethods(['resolvePath', 'touch', 'file_exists', 'getFileInfo'])
+			->setConstructorArgs([])
+			->getMock();
+
+		$this->view->method('touch')
+			->will($this->returnValue(true));
+
+		$this->view
+			->method('resolvePath')
+			->will($this->returnCallback(
+				function ($path) use ($storage) {
+					return [$storage, $path];
+				}
+			));
+
+		$this->view
+			->method('getFileInfo')
+			->will($this->returnCallback(
+				function ($path) {
+					$props = array();
+					$props['checksum'] = null;
+					$props['etag'] = $path;
+					$props['fileid'] = $path;
+					$info = new FileInfo($path, null, null, $props, null);
+					return $info;
+				}
+			));
+
+		$this->info = $this->createMock('OC\Files\FileInfo', [], [], '', false);
+
+		$this->request = $this->getMockBuilder(RequestInterface::class)
+			->disableOriginalConstructor()
+			->getMock();
+
+		$this->response = new \Sabre\HTTP\Response();
+
+		$this->plugin = new BundlingPlugin(
+			$this->view
+		);
+
+		$this->plugin->initialize($this->server);
+	}
+
+	/*TESTS*/
+
+	/**
+	 * This test checks that if url endpoint is wrong, plugin with return exception
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage URL endpoint has to be instance of \OCA\DAV\Files\FilesHome
+	 */
+	public function testHandleBundleNotHomeCollection() {
+
+		$this->request
+			->expects($this->once())
+			->method('getPath')
+			->will($this->returnValue('notFilesHome.xml'));
+
+		$node = $this->getMockBuilder('\OCA\DAV\Connector\Sabre\File')
+			->disableOriginalConstructor()
+			->getMock();
+
+		$this->server->tree->expects($this->once())
+			->method('getNodeForPath')
+			->with('notFilesHome.xml')
+			->will($this->returnValue($node));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Simulate NULL request header
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Content-Type header is needed
+	 */
+	public function testHandleBundleNoHeader() {
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->once())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue(null));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Simulate empty request header
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Content-Type header must not be empty
+	 */
+	public function testHandleBundleEmptyHeader() {
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->once())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue(""));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Simulate content-type header without boundrary specification request header
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Improper Content-type format. Boundary may be missing
+	 */
+	public function testHandleBundleNoBoundraryHeader() {
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->atLeastOnce())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue("multipart/related"));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Simulate content-type header with wrong boundrary specification request header
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Boundary is not set
+	 */
+	public function testHandleBundleWrongBoundraryHeader() {
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->atLeastOnce())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue("multipart/related;thisIsNotBoundrary"));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Simulate content-type header with wrong boundrary specification request header
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Content-Type must be multipart/related
+	 */
+	public function testHandleBundleWrongContentTypeHeader() {
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->atLeastOnce())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue("multipart/mixed; boundary=".self::BOUNDRARY));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Simulate content-type header with alternative correct boundrary specification request header
+	 *
+	 * Request with user out of quota
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage beforeWriteBundle preconditions failed
+	 */
+	public function testHandleAlternativeBoundraryPlusBundleOutOfQuota() {
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->atLeastOnce())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue("multipart/related; boundary=\"".self::BOUNDRARY."\""));
+
+		$this->server
+			->expects($this->once())
+			->method('emit')
+			->will($this->returnValue(false));
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Request without request body
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Unable to get request content
+	 */
+	public function testHandleBundleWithNullBody() {
+		$this->setupServerTillHeader();
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Test empty request body. This will pass getPartHeader, but exception will be raised after we ready headers
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Incorrect Content-type format. Charset might be missing
+	 */
+	public function testHandleBundleWithEmptyBody() {
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody("");
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Test wrong request body
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Expected boundary delimiter in content part - this is not a multipart request
+	 */
+	public function testHandleBundleWithWrongBody() {
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody("WrongBody");
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Test wrong request body, with metadata header containing no charset
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Incorrect Content-type format. Charset might be missing
+	 */
+	public function testHandleMetadataNoCharsetType(){
+		$bodyContent = 'I am wrong metadata not in utf-8';
+		$headers['content-length'] = strlen($bodyContent);
+		$headers['content-type'] = 'text/xml';
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "--".self::BOUNDRARY
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\n\r\n"
+			."$bodyContent\r\n--".self::BOUNDRARY."--";
+
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody($bodyFull);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Test wrong request body, with metadata header containing wrong content-type
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Content-Type must be text/xml
+	 */
+	public function testHandleMetadataWrongContentType(){
+		$bodyContent = 'I am wrong metadata content type';
+		$headers['content-type'] = 'text/plain; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "--".self::BOUNDRARY
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\n\r\n"
+			."$bodyContent\r\n--".self::BOUNDRARY."--";
+
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody($bodyFull);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Test wrong request body, with metadata header containing wrong content-type
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Bundle metadata header does not contain Content-Length. Unable to parse whole bundle request
+	 */
+	public function testHandleMetadataNoContentLength(){
+		$bodyContent = 'I am wrong metadata content type';
+		//$headers['content-length'] = strlen($bodyContent);
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "--".self::BOUNDRARY
+			."\r\nContent-Type: ".$headers['content-type']
+			//."\r\nContent-length: ".$headers['content-length']
+			."\r\n\r\n"
+			."$bodyContent\r\n--".self::BOUNDRARY."--";
+
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody($bodyFull);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Try to parse body which is not xml
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Bundle metadata contains incorrect xml structure. Unable to parse whole bundle request
+	 */
+	public function testHandleWrongMetadataNoXML(){
+		$bodyContent = "I am not xml";
+
+		$this->setupServerTillMetadata($bodyContent);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Try to parse body which has xml d:multipart element which
+	 * has not been declared <d:multipart xmlns:d='DAV:'>
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Bundle metadata does not contain d:multipart children elements
+	 */
+	public function testHandleWrongMetadataWrongXMLdElement(){
+		$bodyContent = "<?xml version='1.0' encoding='UTF-8'?><d:multipart></d:multipart>";
+
+		$this->setupServerTillMetadata($bodyContent);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * This test checks that exception is raised for
+	 * parsed XML which contains empty(without d:part elements) d:multipart section in metadata XML
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Bundle metadata does not contain d:multipart/d:part/d:prop children elements
+	 */
+	public function testHandleEmptyMultipartMetadataSection(){
+		$bodyContent = "<?xml version='1.0' encoding='UTF-8'?><d:multipart xmlns:d='DAV:'></d:multipart>";
+
+		$this->setupServerTillMetadata($bodyContent);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Metadata contains part properties not containing obligatory field will raise exception
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage Undefined index: oc-id
+	 */
+	public function testHandleWrongMetadataNoPartID(){
+		$bodyContent = "<?xml version='1.0' encoding='UTF-8'?>
+			<d:multipart xmlns:d='DAV:'>
+			<d:part>
+				<d:prop>
+				</d:prop>
+			</d:part>
+			</d:multipart>";
+
+		$this->setupServerTillMetadata($bodyContent);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * In the request, insert two files with the same Content-ID
+	 *
+	 * @expectedException \Sabre\DAV\Exception\Forbidden
+	 * @expectedExceptionMessage One or more files have the same Content-ID 1. Unable to parse whole bundle request
+	 */
+	public function testHandleWrongMetadataMultipleIDs(){
+		$bodyContent = "<?xml version='1.0' encoding='UTF-8'?>
+			<d:multipart xmlns:d='DAV:'>
+			<d:part>
+				<d:prop>
+					<d:oc-path>/test/zombie1.jpg</d:oc-path>\n
+					<d:oc-mtime>1476393386</d:oc-mtime>\n
+					<d:oc-id>1</d:oc-id>\n
+					<d:oc-total-length>6</d:oc-total-length>\n
+				</d:prop>
+			</d:part>
+			<d:part>
+				<d:prop>
+					<d:oc-path>/test/zombie2.jpg</d:oc-path>\n
+					<d:oc-mtime>1476393386</d:oc-mtime>\n
+					<d:oc-id>1</d:oc-id>\n
+					<d:oc-total-length>6</d:oc-total-length>\n
+				</d:prop>
+			</d:part>
+			</d:multipart>";
+
+		$this->setupServerTillMetadata($bodyContent);
+
+		$this->plugin->handleBundle($this->request, $this->response);
+	}
+
+	/**
+	 * Specify metadata part without corresponding binary content
+	 *
+	 */
+	public function testHandleWithoutBinaryContent(){
+		$bodyContent = "<?xml version='1.0' encoding='UTF-8'?>
+			<d:multipart xmlns:d='DAV:'>
+			<d:part>
+				<d:prop>
+					<d:oc-path>/test/zombie1.jpg</d:oc-path>\n
+					<d:oc-mtime>1476393386</d:oc-mtime>\n
+					<d:oc-id>1</d:oc-id>\n
+					<d:oc-total-length>6</d:oc-total-length>\n
+				</d:prop>
+			</d:part>
+			</d:multipart>";
+
+		$this->setupServerTillMetadata($bodyContent);
+		$this->plugin->handleBundle($this->request, $this->response);
+		$return = $this->response->getBody();
+		$this->assertTrue(false != $return);
+		$xml = simplexml_load_string($return);
+		$this->assertTrue(false != $xml);
+		$xml->registerXPathNamespace('d','urn:DAV');
+		$xml->registerXPathNamespace('s','http://sabredav.org/ns');
+
+		$this->assertEquals(1, count($xml->xpath('/d:multistatus')));
+
+		$fileMetadataObjectXML = $xml->xpath('/d:multistatus/d:response/d:propstat/d:status');
+		$this->assertTrue(false != $fileMetadataObjectXML);
+		$this->assertEquals(1, count($fileMetadataObjectXML));
+		$this->assertEquals("HTTP/1.1 400 Bad Request", (string) $fileMetadataObjectXML[0]);
+
+		$fileMetadataObjectXML = $xml->xpath('/d:multistatus/d:response/d:propstat/d:prop/d:error/s:message');
+		$this->assertTrue(false != $fileMetadataObjectXML);
+		$this->assertEquals(1, count($fileMetadataObjectXML));
+		$this->assertEquals("File parsing error", (string) $fileMetadataObjectXML[0]);
+	}
+
+	/**
+	 * This test will simulate success and failure in putFile class.
+	 *
+	 */
+	public function testHandlePutFile(){
+		$this->setupServerTillData();
+
+		$this->view
+			->method('file_exists')
+			->will($this->onConsecutiveCalls(true, false, $this->throwException(new StorageNotAvailableException())));
+		
+		$this->plugin->handleBundle($this->request, $this->response);
+
+		$return = $this->response->getBody();
+		$this->assertTrue(false != $return);
+		$xml = simplexml_load_string($return);
+		$this->assertTrue(false != $xml);
+		$xml->registerXPathNamespace('d','urn:DAV');
+		$xml->registerXPathNamespace('s','http://sabredav.org/ns');
+
+		$this->assertEquals(1, count($xml->xpath('/d:multistatus')));
+
+		$fileMetadataObjectXML = $xml->xpath('/d:multistatus/d:response/d:propstat/d:status');
+		$this->assertTrue(false != $fileMetadataObjectXML);
+		$this->assertEquals(3, count($fileMetadataObjectXML));
+		$this->assertEquals("HTTP/1.1 400 Bad Request", (string) $fileMetadataObjectXML[0]);
+		$this->assertEquals("HTTP/1.1 200 OK", (string) $fileMetadataObjectXML[1]);
+		$this->assertEquals("HTTP/1.1 400 Bad Request", (string) $fileMetadataObjectXML[2]);
+
+		$fileMetadataObjectXML = $xml->xpath('/d:multistatus/d:response/d:propstat/d:prop/d:error/s:message');
+		$this->assertTrue(false != $fileMetadataObjectXML);
+		$this->assertEquals(2, count($fileMetadataObjectXML));
+		$this->assertEquals("Bundling not supported for already existing files", (string) $fileMetadataObjectXML[0]);
+		$this->assertEquals("StorageNotAvailableException raised", (string) $fileMetadataObjectXML[1]);
+	}
+
+	/*UTILITIES*/
+
+	private function setupServerTillData(){
+		$bodyContent = "<?xml version='1.0' encoding='UTF-8'?>
+			<d:multipart xmlns:d='DAV:'>
+			<d:part>
+				<d:prop>
+					<d:oc-path>/test/zombie1.jpg</d:oc-path>\n
+					<d:oc-mtime>1476393386</d:oc-mtime>\n
+					<d:oc-id>0</d:oc-id>\n
+					<d:oc-total-length>7</d:oc-total-length>\n
+				</d:prop>
+			</d:part>
+			<d:part>
+				<d:prop>
+					<d:oc-path>/test/zombie2.jpg</d:oc-path>\n
+					<d:oc-mtime>1476393386</d:oc-mtime>\n
+					<d:oc-id>1</d:oc-id>\n
+					<d:oc-total-length>7</d:oc-total-length>\n
+				</d:prop>
+			</d:part>
+			<d:part>
+				<d:prop>
+					<d:oc-path>zombie3.jpg</d:oc-path>\n
+					<d:oc-mtime>1476393232</d:oc-mtime>\n
+					<d:oc-id>2</d:oc-id>\n
+					<d:oc-total-length>7</d:oc-total-length>\n
+				</d:prop>
+			</d:part>
+			</d:multipart>";
+
+		$headers['content-length'] = strlen($bodyContent);
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "--".self::BOUNDRARY
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\nContent-length: ".$headers['content-length']
+			."\r\n\r\n"
+			."$bodyContent"
+			."\r\n--".self::BOUNDRARY
+			."\r\nContent-ID: 0"
+			."\r\n\r\n"
+			."zombie1"
+			."\r\n--".self::BOUNDRARY
+			."\r\nContent-ID: 1"
+			."\r\n\r\n"
+			."zombie2"
+			."\r\n--".self::BOUNDRARY
+			."\r\nContent-ID: 2"
+			."\r\n\r\n"
+			."zombie3"
+			."\r\n--".self::BOUNDRARY."--";
+
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody($bodyFull);
+	}
+
+	private function setupServerTillMetadata($bodyContent){
+		$headers['content-length'] = strlen($bodyContent);
+		$headers['content-type'] = 'text/xml; charset=utf-8';
+
+		//this part will have some arbitrary, correct headers
+		$bodyFull = "--".self::BOUNDRARY
+			."\r\nContent-Type: ".$headers['content-type']
+			."\r\nContent-length: ".$headers['content-length']
+			."\r\n\r\n"
+			."$bodyContent\r\n--".self::BOUNDRARY."--";
+
+		$this->setupServerTillHeader();
+
+		$this->fillMultipartContentsParserStreamWithBody($bodyFull);
+	}
+
+	private function setupServerTillHeader(){
+		$this->setupServerTillFilesHome();
+
+		$this->request
+			->expects($this->atLeastOnce())
+			->method('getHeader')
+			->with('Content-Type')
+			->will($this->returnValue("multipart/related; boundary=".self::BOUNDRARY));
+
+		$this->server
+			->expects($this->once())
+			->method('emit')
+			->will($this->returnValue(true));
+	}
+
+	private function setupServerTillFilesHome(){
+		$this->request
+			->expects($this->once())
+			->method('getPath')
+			->will($this->returnValue('files/admin'));
+
+		$node = $this->getMockBuilder('\OCA\DAV\Files\FilesHome')
+			->disableOriginalConstructor()
+			->getMock();
+
+		$this->server->tree->expects($this->once())
+			->method('getNodeForPath')
+			->with('files/admin')
+			->will($this->returnValue($node));
+	}
+
+	private function fillMultipartContentsParserStreamWithBody($bodyString){
+		$bodyStream = fopen('php://temp', 'r+');
+		fwrite($bodyStream, $bodyString);
+		rewind($bodyStream);
+
+		$this->request->expects($this->any())
+			->method('getBody')
+			->willReturn($bodyStream);
+	}
+
+	public function tearDown() {
+		$userManager = \OC::$server->getUserManager();
+		$userManager->get($this->user)->delete();
+		unset($_SERVER['HTTP_OC_CHUNKED']);
+
+		parent::tearDown();
+	}
+}
diff --git a/apps/dav/tests/unit/Files/BundledFileTest.php b/apps/dav/tests/unit/Files/BundledFileTest.php
index 67e9aca8c11b..692daf60c9e4 100644
--- a/apps/dav/tests/unit/Files/BundledFileTest.php
+++ b/apps/dav/tests/unit/Files/BundledFileTest.php
@@ -21,10 +21,6 @@
 
 namespace OCA\DAV\Files;
 
-use OC\Files\Storage\Local;
-use OCP\Files\ForbiddenException;
-use Test\HookHelper;
-use OC\Files\Filesystem;
 use OCP\Lock\ILockingProvider;
 
 /**
@@ -55,14 +51,6 @@ public function setUp() {
 		$this->loginAsUser($this->user);
 	}
 
-	public function tearDown() {
-		$userManager = \OC::$server->getUserManager();
-		$userManager->get($this->user)->delete();
-		unset($_SERVER['HTTP_OC_CHUNKED']);
-
-		parent::tearDown();
-	}
-
 	/* TESTS */
 
 	/**
@@ -123,6 +111,14 @@ private function getMockStorage() {
 		return $storage;
 	}
 
+	public function tearDown() {
+		$userManager = \OC::$server->getUserManager();
+		$userManager->get($this->user)->delete();
+		unset($_SERVER['HTTP_OC_CHUNKED']);
+
+		parent::tearDown();
+	}
+
 	/**
 	 * @param string $string
 	 */
@@ -134,11 +130,14 @@ private function getStream($string) {
 	}
 
 	/**
-	 * TODO:
+	 * Do basic put for single bundled file
 	 */
-	private function doPutFIle($fileMetadata, $contentHandler, $viewRoot = null) {
+	private function doPutFIle($fileMetadata, $contentHandler, $view = null, $viewRoot = null) {
 		$path = $fileMetadata['oc-path'];
-		$view = \OC\Files\Filesystem::getView();
+
+		if(is_null($view)){
+			$view = \OC\Files\Filesystem::getView();
+		}
 		if (!is_null($viewRoot)) {
 			$view = new \OC\Files\View($viewRoot);
 		} else {

